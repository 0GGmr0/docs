= Repy Tutorial =

----
[[TOC(inline)]]
----

[[BR]]
== Introduction ==
----

This guide provides an introduction to using the repy sandbox environment.  It describes who would want to use repy, how to perform actions in the sandboxed environment, and what restrictions are placed upon the sandboxed code.   At the end of reading this document you should be able to write repy programs, manage the restrictions on programs, and understand whether repy is appropriate for a specific task or program.

It is assumed that you have a basic understanding of ports and IP addresses.  Also, a basic understanding of HTML is useful but not required.  Lastly, you need a basic understanding of the Python programming language.  If not, you might want to first read through the Python tutorial at http://www.python.org/doc/. You do not need to be a Python expert to use repy, but as repy is a subset of Python, being able to write a simple Python program is essential.

[[BR]]
=== What is repy and who should use it? ===
----

Repy is a sandboxed environment that is intended for educational and research use.   The idea is that a user can install repy on their system and researchers and students can run code on their system '''without significantly impacting the security or performance of the host system'''.   To provide security and performance isolation, the programs that run on repy are restricted in what they can do and when they can do it.  

[[BR]]
=== When should I use repy? ===
----

Repy is ideal for students, researchers, and companies that want to prototype code and have it run on as many computers as possible.   <completely unsubstantiated claims> Repy has performance comparable to native Python and is safe for untrusted code to run on.</completely unsubstantiated claims>   The focus on repy is on safety.   If you need access to more complex mechanisms than what the sandbox provides (direct access to hardware, running C code, etc.), repy is not for you.  

[[BR]]
=== How is this different than BOINC (SETI@Home, etc.)? ===
----

In BOINC the focus is on using spare CPU cycles from home machines.   To BOINC, getting 1% of the time on 1000 computers is similar to getting 100% on 10 computers (for similar computers).   With repy it is much more useful to get 1% on 1000 computers because the research and educational programs are trying to understand how to write scalable programs that run on many computers at the same time.   The problems and programs become interesting when there are thousands of computers.  

Also BOINC uses only CPU cycles when the system would be idle so as to avoid interfering with the user.   BOINC typically uses almost all of the CPU when it's idle.   With repy, it is more desirable to constantly have a small percentage of the resources (this allows a smaller percentage of resources to be used over a longer time period).

[[BR]]
== General Operations ==
----

[[BR]]
=== A simple example (example 1.1) ===
----

The way to execute the codes in Repy is in the [PythonTutorial Python tutorial] page.

A simple "helloworld.py" repy program looks like this:

{{{
#!python
if callfunc == "initialize":
  print "hello world"
}}}

This program states that if I'm being called during initialization, I should print "hello world" to my log.   By default the log is the shell you are using when you run repy from the command line.   On some architectures you will also see a line like "Terminated".

To run this using repy, execute the following from the command line:

{{{
#!python
python repy.py restrictions.test test.py
}}}

You need to make sure that you have repy.py, restrictions.test, and helloworld.py in the same directory where your command line is pointing.

Output is below.

{{{
#!python
Hello World
Terminated
}}}

To run a program in the vessel, you should use the experiment manager seash. Seash allows you to control the files running in sandboxes you control.

Before using the experiment manager seash, you need to create a ID and generate public and private keys. The instruction is on https://seattle.cs.washington.edu/wiki/DeveloperSetup.

The instruction to run a program with seash is in the [PythonTutorial Python tutorial].

Note that if you instead write the program:

{{{
#!python
print "hello world"
}}}

you will see output like:

{{{
#!python
hello world
hello world
}}}

The reason why is that your code is called different times for different events (initialize and exit).   If you change the program to read:

{{{
#!python
print "hello world",callfunc
}}}

You'll see:

{{{
#!python
hello world initialize
hello world exit
}}}

In python it is considered good practice to have a python module with a check to see whether it was imported or the main module and only call main when appropriate:

{{{
#!python
if __name__ == "__main__":    # This is not valid repy code!!!  
  main()
}}}

The equivalent code for repy is:

{{{
#!python
if callfunc == "initialize":
  my_initialize()
elif callfunc == "exit":
  my_exit()
}}}

Repy is the event-driven programming language. It initially has two events. The initialize event initializes all functions in the program and exit event checks whether the events generated in the program are terminated. Programmers don't have to insert any code at the end of the code to check whether all events are terminated before exit.

[[BR]]
=== A more realistic Hello World example (example 1.2) ===
----

In this example, we'll wait for the user to browse a port we listen on.   When the user browses our page, we'll display a hello world webpage and then exit.   Create a file "helloworldwebpage.py" with the following text:

{{{
#!python
def hello(ip,port,sockobj, thiscommhandle,listencommhandle):
 
  sockobj.send("<html><head><title>Hello World</title></head><body><h1> Hello World! </h1></body></html>")
  stopcomm(thiscommhandle)   # close my connection with this user (we could also do sockobj.close())

if callfunc == 'initialize':
  listencommhandle = waitforconn("127.0.0.1",12345,hello)   # whenever we get a connection on 127.0.0.1:12345 we'll call hello
}}}

The initialize portion says, wait for a connection on 127.0.0.1 (the "local" IP of the computer), port 12345 and when you get it call the function hello().  
The waitforconn() function returns a commhandle.   A commhandle is a way for your program to refer to a connection.   You can pass a commhandle to other functions to do operations.   For example, when you want to close a connection you can call stopcomm with the commhandle for the connection that should be closed.

The hello() function is called with 5 arguments: the ip address and port of the person who is connecting, a sockobj that can be used to communicate with the other end of the connection, a commhandle for the connection, and the commhandle that hello is registered on.   The function hello sends the webpage (the text in quotes) using the sockobj and then closes the current connection (using the commhandle).

Run this program the same as in the previous example, substituting "run helloworldwebpage.py" for "run helloworld.py"

{{{
#!python
default@browsegood !> run helloworldwebpage.py  
default@browsegood !> list                            
  ID   Own                  Name                     Status              Owner Information
  %1     *       IP address:port:vesselname        Started     
}}}

Notice that the program is "Started" instead of "Terminated". It's still running! 

Then open a web browser and in the address bar type: 127.0.0.1:12345  (this says to navigate to the "local" IP of the computer at port 12345).   You should see the hello world webpage.  

To stop the program, in the shell type:

{{{
#!python
default@browsegood !> stop                     # This will stop any programs that are still running...  
default@browsegood !> list                          
  ID    Own                    Name                 Status              Owner Information
  %1      *          IP address:port:vesselname    Stopped   
}}}

Notice that the program is now "Stopped".   It's not running

[[BR]]
=== Counting the number of calls (example 1.3) ===
----

In this example, we'll add a counter to our helloworld pprogram.   First we'll try some perfectly valid python code that will not work in repy.

{{{
#!python
def hello(ip,port,sockobj, thiscommhandle,listencommhandle):
  global pagecount   # GLOBALS ARE NOT ALLOWED IN REPY
  pagecount = pagecount + 1
  sockobj.send("<html><head><title>Hello World</title></head><body><h1> Hello World!</h1><p>You are visitor "+str(pagecount)+"</body></html>")
  stopcomm(thiscommhandle)   # close my connection with this user

if callfunc == 'initialize':
  global pagecount   # GLOBALS ARE NOT ALLOWED IN REPY
  pagecount = 0
  listencommhandle = waitforconn("127.0.0.1",12345,hello)   # whenever we get a connection on 127.0.0.1:12345 we'll call hello
}}}

This code will not work because globals do not exist in repy.   However, there is a mycontext dictionary provided for this purpose.   The code can be written as follows:

{{{
#!python
def hello(ip,port,sockobj, thiscommhandle,listencommhandle):
  mycontext['pagecount'] = mycontext['pagecount'] + 1
  sockobj.send("<html><head><title>Hello World</title></head><body><h1> Hello World!</h1><p>You are visitor "+str(mycontext['pagecount'])+"</body></html>")
  stopcomm(thiscommhandle)   # close my connection with this user

if callfunc == 'initialize':
  mycontext['pagecount'] = 0
  listencommhandle = waitforconn("127.0.0.1",12345,hello)   # whenever we get a connection on 127.0.0.1:12345 we'll call hello
}}}

Start the program using the shell, then open a web browser and in the address bar type: 127.0.0.1:12345  (this says to navigate to the "local" IP of the computer at port 12345).   You should see the hello world webpage and a count of 1.   You can refresh the page and the count should increment.   Once again,use the shell to stop the program

[[BR]]
=== Adding a Timer and listing the elapsed time (example 1.4) ===
----

The previous program would wait forever for a user to connect so it could display a webpage.   What if you wanted to have the program timeout after 1 minute?   To do this, we'll register a timer that will close the connection.

{{{
#!python
def hello(ip,port,sockobj, thiscommhandle,listencommhandle):
  mycontext['pagecount'] = mycontext['pagecount'] + 1
  sockobj.send("<html><head><title>Hello World</title></head><body><h1> Hello World!</h1><p>You are visitor "+str(mycontext['pagecount'])+"<p>I've been running "+str(getruntime())+" seconds</body></html>")
  stopcomm(thiscommhandle)   # close my connection with this user
 
def stop_listening(commhandle):
  stopcomm(commhandle)   # this will deregister hello

if callfunc == 'initialize':
  mycontext['pagecount'] = 0
  listencommhandle = waitforconn("127.0.0.1",12345,hello)   # whenever we get a connection on 127.0.0.1:12345 we'll call hello
  eventhandle = settimer(60, stop_listening, (listencommhandle,)) # wait 60 seconds, then call stop_listening with listencommhandle
}}}
 
The timer (when called) will stop the communication.  settimer returns an eventhandle.   An eventhandle is similar to a commhandle in that it can be used to interact with an event.   getruntime() is used to provide the amount of time that has elapsed since the program was started.   Note that it may be possible for the elapsed time to be > 60 seconds in this program because there may be some lag between when the program started and when your code ran or a delay in running the stop_listening event.

Start the program and then open a web browser and in the address bar type: 127.0.0.1:12345.   You'll notice that the webpage displays and after 1 minute the program will stop listening and stop itself.   You'll see that the program's status is "Terminated" because it caused itself to exit (as opposed to "Stopped" where you stopped it while it was running).

[[BR]]
=== Interacting with Timers (example 1.5) ===
----

The previous program would wait forever for a user to connect so it could display a webpage.   What if you wanted to have the program stop if it doesn't display a web page for 10 seconds?   Well, we know how to set a timer to close the connection in 10 seconds, but that doesn't help us to keep the connection open.   To have the connection kept open while requests continue to happen, every time we get a request we'll cancel the existing timer and set a new timer for 10 seconds in the future that will close the connection.  

{{{
#!python
def hello(ip,port,sockobj, thiscommhandle,listencommhandle):
  mycontext['pagecount'] = mycontext['pagecount'] + 1
  sockobj.send("<html><head><title>Hello World</title></head><body><h1> Hello World!</h1><p>You are visitor "+str(mycontext['pagecount'])+"</body></html>")
  stopcomm(thiscommhandle)   # close my connection with this user

  # stop the previous timer...
  canceltimer(mycontext['stopevent'])
  # start a new one for 10 seconds from now...
  eventhandle = settimer(10, stop_listening, (listencommhandle,))
  mycontext['stopevent'] = eventhandle
 
def stop_listening(commhandle):
  stopcomm(commhandle)   # this will deregister hello

if callfunc == 'initialize':
  mycontext['pagecount'] = 0
  listencommhandle = waitforconn("127.0.0.1",12345,hello)  
  eventhandle = settimer(10, stop_listening, (listencommhandle,))
  mycontext['stopevent'] = eventhandle
}}}
 
The timer (when called) will stop the communication.  canceltimer stops a timer (if it hasn't already started).  

Try running the program and then try browsing the webpage a few times and then wait.   You'll notice the connection closes 10 seconds after you stop browsing. 

[[BR]]
=== Races, Sleep, and Locks (example 1.6) ===
----

The wily reader may have noticed that the previous program has a race condition.   (explain what a race is here).   It is possible to have multiple browser windows browse 127.0.0.1 at the same time.   It is possible for browser window A to cancel the timer, but before it adds the new eventhandle to mycontext['stopevent'], window B could also try to cancel the timer and set up its own event.   Now there are two events that will stop communications and only one of these will be listed in mycontext['stopevent'].   This means that regardless of how often a user views the webpages, the other event will fire because there is no reference to the eventhandle.   The connection will be closed (not what we want!).   It would be difficult to trigger this condition manually, but we'll use a command "sleep" to pause the current function for some amount of time to allow us to trigger the bug so that we can see it in practice.

{{{
#!python
def hello(ip,port,sockobj, thiscommhandle,listencommhandle):
  mycontext['pagecount'] = mycontext['pagecount'] + 1
  sockobj.send("<html><head><title>Hello World</title></head><body><h1> Hello World!</h1><p>You are visitor "+str(mycontext['pagecount'])+"</body></html>")
  stopcomm(thiscommhandle)   # close my connection with this user
  canceltimer(mycontext['stopevent'])
  sleep(5)   # give me 5 seconds to trigger the race
  eventhandle = settimer(10, stop_listening, (listencommhandle,)) # wait 60 seconds, then call stop_listening with listencommhandle
  mycontext['stopevent'] = eventhandle
 
def stop_listening(commhandle):
  stopcomm(commhandle)   # this will deregister hello

if callfunc == 'initialize':
  mycontext['pagecount'] = 0
  listencommhandle = waitforconn("127.0.0.1",12345,hello)   # whenever we get a connection on 127.0.0.1:12345 we'll call hello
  eventhandle = settimer(10, stop_listening, (listencommhandle,)) # wait 60 seconds, then call stop_listening with listencommhandle
  mycontext['stopevent'] = eventhandle
}}}
 
Try browsing the webpage a few times rapidly and then browse every 3-5 seconds.   You'll notice the program closes automatically even though it shouldn't (because you kept browsing).  

One way to fix a race condition is using a lock.   You can get a lock by calling getlock().   A lock supports two operations: acquire and release and is similar to the Python threading.Lock class.

We can avoid race conditions by the following changes:

{{{
#!python
def hello(ip,port,sockobj, thiscommhandle,listencommhandle):
  mycontext['pagecount'] = mycontext['pagecount'] + 1
  sockobj.send("<html><head><title>Hello World</title></head><body><h1> Hello World!</h1><p>You are visitor "+str(mycontext['pagecount'])+"</body></html>")
  stopcomm(thiscommhandle)   # close my connection with this user

  mycontext['stoplock'].acquire() # acquire the lock

  canceltimer(mycontext['stopevent'])
  eventhandle = settimer(10, stop_listening, (listencommhandle,)) # wait 60 seconds, then call stop_listening with listencommhandle
  mycontext['stopevent'] = eventhandle

  mycontext['stoplock'].release() # release the lock
 
def stop_listening(commhandle):
  stopcomm(commhandle)   # this will deregister hello

if callfunc == 'initialize':
  mycontext['pagecount'] = 0
  mycontext['stoplock'] = getlock()
  listencommhandle = waitforconn("127.0.0.1",12345,hello)   # whenever we get a connection on 127.0.0.1:12345 we'll call hello
  eventhandle = settimer(10, stop_listening, (listencommhandle,)) # wait 60 seconds, then call stop_listening with listencommhandle
  mycontext['stopevent'] = eventhandle
}}}

Now if you run the program repeatedly, it shouldn't be possible to trigger a race condition.   Note that since only one event can be in the section of the code protected with locks, if you put a sleep in there and rapidly browse, you may have your program slow down because there are not enough free events.  

[[BR]]
== File Operations ==
----

[[BR]]
=== Introduction to Files (example 2.1) ===
----

We'll now switch gears from our hello world web server and focus instead on writing data to files.   The first program we'll write will write the string "hello world" to a file and then read it back out and print it.

{{{
#!python
if callfunc == 'initialize':
  myfileobject = open("hello.file","w")   # just like python's open() function
  print >> myfileobject, "hello world"     # we also could have used myfileobject.write("hello world\n")
  myfileobject.close()

  newfileobject = file("hello.file","r")   # we can use file instead of open.   They work the same...
  print newfileobject.read()
  newfileobject.close()
}}}

This program should print hello world (and an extra newline from print).   The repy file object is similar to python's file object so you can do things like:

{{{
#!python
for line in file("hello.file","r"):
  # code here
  ...
}}}

[[BR]]
=== Listing and Removing Files (example 2.2) ===
----

In this example, we'll change our program to write information to a few different files and after we're finished, we'll remove the files.   Instead of coding in the program which files to write information to, we'll let our command line arguments specify which files to write.

{{{
#!python
if callfunc == 'initialize':
  for filename in callargs:   # callargs has all of the command line arguments in it.
    myfileobject = open(filename,"w")   # just like python's open() function
    print >> myfileobject, "hello world"     # we also could have used myfileobject.write("hello world\n")

    myfileobject.close()

  print listdir()   # now we'll go through and print the files in this directory (it may include things other than our files).

  for filename in callargs:   # let's remove our files now...
    removefile(filename)  

  print "The files:",callargs," should now be missing from ",listdir()  
}}}

You should see output that first lists the file names in the current directory (along with the files you chose to write) and then shows the listing missing the files.   Note that if you choose file names with characters like "/", "\", "@", or other non-alphanumeric characters you may get an error because repy programs are not allowed to use certain characters in file names.

[[BR]]
== Network Operations 1 ==
----

 [[BR]]
=== Interacting with other computers (example 3.1) ===
----

In this example, we'll retrieve a webpage and print it on the screen.   We're not going to translate all of the HTML or remove the HTTP headers, so it will be a bit messy.  

{{{
#!python
if callfunc == 'initialize':
 
  socketobject = openconn("www.google.com",80)   # open a connection to the google web server
  socketobject.send("GET /index.html http/1.1\r\nHost: www.google.com\r\n\r\n")    # this is a HTTP request...

  while True:
     print socketobject.recv(4096)
}}}
   
You should see google's webpage along with some numbers and other information (this is the HTTP protocol).   However, the program does not stop (at least until you press CTRL-C)!   This is because HTTP 1.1 allows us to issue multiple page requests on a single connection.  

[[BR]]
=== Causing a program to exit (example 3.2) ===
----

In this example, we'll change the previous program to exit after we receive the data from google.   To do this we'll use a function called exitall().   This function causes the program to abort and all threads to exit immediately.   We can add this to a timer to the previous example as follows:

{{{
#!python
if callfunc == 'initialize':

  socketobject = openconn("www.google.com",80)   # open a connection to the google web server
  socketobject.send("GET /index.html http/1.1\r\nHost: www.google.com\r\n\r\n")    # this is a HTTP request...

  # We'll loop and print information from google.   We don't "speak" HTTP, so we'll set a timer to exit in 3 seconds
  settimer(3, exitall, ())
  while True:
     print socketobject.recv(4096)
}}}
 
Alternatively, we could instead close the socket and check this condition.   Example code that shows this is below

{{{
#!python
if callfunc == 'initialize':

  socketobject = openconn("www.google.com",80)   # open a connection to the google web server
  socketobject.send("GET /index.html http/1.1\r\nHost: www.google.com\r\n\r\n")    # this is a HTTP request...

  # We'll loop and print information from google.   We don't "speak" HTTP, so we'll set a timer to close the socket in 3 seconds
  settimer(3, socketobject.close, ())
  while True:
     try:
       print socketobject.recv(4096)
     except Exception, e:    # we got an exception.   Did they close the socket?
       if str(e) != "Socket closed":
         raise
       break
}}}

[[BR]]
== Network Operations 2 ==
----

[[BR]]
=== Looking up IP addresses (example 4.1) ===
----

In this example, we'll look up some IP addresses using gethostname_ex:

{{{
#!python
if callfunc == 'initialize':
  print gethostbyname_ex("www.google.com")
  print gethostbyname_ex("www.wikipedia.com")
  print getmyip()
}}}

This will print IP address, hostname and other information for google and wikipedia and will also print the current computer's IP address.   For more information about the format of the data returned from gethostbyname_ex see socket.gethostbyname_ex.

[[BR]]
=== Sending and receiving messages (example 4.2) ===
----

In this example, we'll manually send a NTP (time) lookup message and print the raw data that is returned.   Rather than hard code a server into our program, we'll randomly choose a server from a list of publicly available time servers.   A lot of the complexity in this program comes with encoding and decoding NTP data.  

{{{
#!python
# See RFC 2030 (http://www.ietf.org/rfc/rfc2030.txt) for details about NTP
def convert_timestamp_to_float(timestamp):   # this unpacks the data from the packet and changes it to a float
  integerpart = (ord(timestamp[0])<<24) + (ord(timestamp[1])<<16) + (ord(timestamp[2])<<8) + (ord(timestamp[3]))
  floatpart = (ord(timestamp[4])<<24) + (ord(timestamp[5])<<16) + (ord(timestamp[6])<<8) + (ord(timestamp[7]))
  return integerpart + floatpart / float(2**32)

def decode_NTP_packet(ip, port, mess, ch):
  print "From "+str(ip)+":"+str(port)+", I received NTP data."
  print "NTP Reference Identifier:",mess[12:16]
  print "NTP Transmit Time (in seconds since Jan 1st, 1900):", convert_timestamp_to_float(mess[40:48])
  stopcomm(ch)

if callfunc == 'initialize':
  ip = getmyip()
  timeservers = ["time-a.nist.gov", "time-b.nist.gov", "time-a.timefreq.bldrdoc.gov", "time-b.timefreq.bldrdoc.gov", "time-c.timefreq.bldrdoc.gov", "utcnist.colorado.edu", "time.nist.gov", "time-nw.nist.gov", "nist1.symmetricom.com", "nist1-dc.WiTime.net", "nist1-ny.WiTime.net", "nist1-sj.WiTime.net", "nist1.aol-ca.symmetricom.com", "nist1.aol-va.symmetricom.com", "nist1.columbiacountyga.gov", "nist.expertsmi.com", "nist.netservicesgroup.com"]

  # choose a random time server from the list
  servername = timeservers[int(randomfloat()*len(timeservers))]
  print "Using: ", servername

  # this sends a request, version 3 in "client mode"
  ntp_request_string = chr(27)+chr(0)*47
  recvmess(ip,12345, decode_NTP_packet)
  sendmess(servername,123, ntp_request_string, ip, 12345) # port 123 is used for NTP
}}}

This will print the number of seconds since Jan 1st, 1900 from a time server.   If you run the program multiple times, you'll see it chooses servers randomly from the timeservers list.  

One thing to note, connection functions like opencomm and waitforcomm use different ports (TCP) than message functions like sendmess and recvmess (UDP).  

Getting the time from a synchronized time source is a handy thing to do (so this isn't bad code to repurpose for your code).   You shouldn't ask for the time repeatedly from the time servers though (they consider requests more frequent than 4 seconds apart to be a DoS attack).   You can ask once for a global reference time and then use getruntime to measure the elapsed time.

[[BR]]
== Restrictions ==
----

In the previous examples, we've been running code on our local system which we have control over.   When deploying repy programs, you may instead end up running your code on systems that don't belong to you.   Since you don't control these systems, the users are likely to have a set of restrictions on what you can do on their computer.   You may be unable to write files to disk, not be able to send packets to certain IP addresses, or prevented from performing operations.  

To get a restrictions / restrictions file, in the shell type: show resources.   If you look at a restrictions file, you'll see a bunch of lines like this (ignore the resource lines for now):

{{{
#!python
call sendmess allow
call stopcomm allow                     # it doesn't make sense to restrict
call recvmess allow
call openconn allow
call waitforconn allow
call socket.close allow                 # let's not restrict
call socket.send allow                  # let's not restrict
call socket.recv allow                  # let's not restrict

# open and file.__init__ both have built in restrictions...
call open arg 0 is junk_test.out allow  # can write to junk_test.out
call open arg 1 is r allow              # allow an explicit read
call open noargs is 1 allow             # allow an implicit read
call file.__init__ arg 0 is junk_test.out allow # can write to junk_test.out
call file.__init__ arg 1 is r allow     # allow an explicit read
call file.__init__ noargs is 1 allow    # allow an implicit read
call file.close allow                   # shouldn't restrict
call file.flush allow                   # they are free to use
call file.next allow                    # free to use as well...
call file.read allow                    # allow read
call file.readline allow                # shouldn't restrict
call file.readlines allow               # shouldn't restrict
call file.seek allow                    # seek doesn't restrict
call file.write allow                   # shouldn't restrict (open restricts)
call file.writelines allow              # shouldn't restrict (open restricts)
call sleep allow                        # harmless
call settimer allow                     # we can't really do anything smart
call canceltimer allow                  # should be okay
call exitall allow                      # should be harmless
call log.write allow                    # allows printing to the log
call log.writelines allow            # a different format of printing to the log
call getmyip allow                      # They can get the external IP address
call listdir allow                      # They can list the files they created
call removefile allow                   # They can remove the files they create
call randomfloat allow                  # can get random numbers
call getruntime allow                   # can get the elapsed time
call getlock allow                      # can get a lock
}}}

These lines specify which functions the program is allowed to call.   They may also list the arguments that can be passed.   When you create a program, you should decide which actions it needs to perform.   It is easier for you to locate computers you can run on if your program has fewer requirements.   You can specify that a function can only be called with a certain number of arguments or certain arguments.   This can be helpful to restrict your program to use certain filenames or functions.  

[[BR]]
== Resources ==
----

In the previous section, we looked at restrictions; a mechanism for allowing or denying an action.   These aren't adequate for many cases.   For example, you can say a program can or cannot write files, but you cannot say that a program can only write 1MB worth of files.   This is where resources come in.   They put limits on the number of resources a program can consume.

If you look at a restrictions / resources file, you'll see a bunch of lines like this:

{{{
#!python
resource cpu .10
resource memory 10000000   # 10 Million bytes
resource diskused 10000000 # 10 MB
resource events 10
resource filewrite 10000
resource fileread 10000
resource filesopened 5
resource insockets 5
resource outsockets 5
resource netsend 10000
resource netrecv 10000
resource loopsend 1000000
resource looprecv 1000000
resource lograte 30000
resource random 100
resource messport 12345
resource messport 12346
resource connport 12345
}}}

These lines specify the type and quantity of resources the program can consume.   Some resources like CPU, the netsend / recv rate, random number generation rate, etc. are for renewable resources.   Renewable resources are resources that replenish themselves over time.   For example, if your program is using too much CPU, it will be paused temporarily to allow other programs to run.    Trying to use too much of a renewable resource will cause a call to run slowly.

Alternatively, other resources like memory, disk used, sockets, etc. are not renewable.   In other words, the resource has a hard limit and is does does not automatically replenish itself over time.   When you use too much of one of these resources, the call in your program which causes it to be over the limit may raise an exception or in some cases the program may be killed outright.  

For more information about resources and restrictions see the resources and restrictions guide.

[[BR]]
== Conclusion ==
----

This concludes a brief tour of the repy functionality.   This guide has covered all of the API calls for repy.   For more detailed information see the Library Reference and the Resources and Restrictions guide.   You should now be able to build your own repy applications that can run on hundreds of computers.   Good luck!