= !GeniPortal Version 3 Design Document/Proposal =

This is a proposal for the rewrite of the !GeniPortal. Feedback welcome (e.g. comments here, to jsamuel, or to the list).

[[TOC(inline)]]

----

== Design Goals ==

  * Greater understandability and maintainability.
    * Current design is more difficult than necessary for new people to understand.
  * Easier testing.
    * Current design's lack of modularity makes testing difficult.
  * Better logging.
    * Design not only needs to incorporate better logging, but needs to allow easy future addition of logging.
  * Eliminate race conditions.
    * Current implementation has various race conditions related to database access.
  * Improve security.
    * Minimize the impact of website/webserver compromise.

----

== New Design Plan ==

At a high level, the idea will be to:
  * Take the existing concept of a separate backend server and extend it to handling most data-modifying and node-modifying actions.
  * Implement an explicit queue of actions in the backend server.
  * Move all keys to a separate keyserver.
  * Limit the website's role to mostly very simple data access, minimally-privileged keyserver requests, and interacting with the backend server.

=== Website ===

[[Image(geniportal_v3_website.gif)]]

  * End clients communicate with the website through either XML-RPC or HTTP.
  * The request's authorization is checked (e.g. ensure valid sesssion for HTTP) and
    the request is then sent through the Controller Interface.
  * The Controller then processes the request based on the type of request.
    * A request for a user to acquire/release vessels will be sent to the backend through
      the Backend API.
    * A request to obtain the user's public or private key, or to delete the user's
      private key, will go through the Keyserver Low-Auth API (the only keyserver API calls that
      the website has sufficient privileges to execute).
    * Certain safe and simple database needs may go directly to the database through a
      Main DB Website API. This prevents the need to send every potential query through the
      backed server, which may add unecessary complication and performance impacts.
      At a minimum this would include reading and updating user account information that could
      not interfere with backend operations.
      * This is called the "Main DB Website API" mostly just to emphasize that only a few
        direct database actions will be performed by the Controller.

Note that the Website could just do more/everything through the backend server, but that might result in
excessive communication to fulfill simple website requests and clutter the backend interface.
This is open for debate and change. For example, it
might be worthwhile to require user private key reading (for download by the user) to go through the
backend server, but this may be extra indirection for little benefit.

=== Backend ===

[[Image(geniportal_v3_backend.gif)]]

The Backend performs fundamentally the same purpose as the current backend implementation. It
provides a means for other code to hand off non-trivial tasks to a process that can ensure the
tasks are done correctly and efficiently (proper ordering, mutual exclusion for shared data
access, safely parallelized operations).

The Backend maintains an explicit Queue of tasks which are stored in a database. The tasks
in the Queue are processed by a thread called the Queue Runner.

The Backend exposes a private XML-RPC interface for use by other code within the system,
including the Website and Polling Daemons.
  * Requests that can be safely fulfilled without risk of data access conflicts can be fulfilled immediately without being entered in the Queue.
    * Such requests are inherently synchronous requests.
  * Requests that cannot be safely fulfilled without risk of data access conflicts are entered in the Queue.
    * Such requests are inherently asynchronous requests, but the Backend XML-RPC Interface can also provide a synchronous interface to any such action.
      * For these requests, a task_id is assigned (the id in the Queue).
      * For XML-RPC requests that are intended to be asynchronous requests, the task_id is returned and can be used to query the status of the task later.
      * For XML-RPC requests that are intended to be synchronous, the response can block until the queued task has been performed.

The method by which the Backend determines that a privileged request is authorized is not specified here for the moment. It may be as simple as a passphrase included with the request. Other security measures to be taken include only accepting requests from known IPs. 

=== Polling Daemons ===

[[Image(geniportal_v3_polling_daemons.gif)]]

Polling Daemons are any processes or scripts that perform general monitoring of nodes
as well as node state transition functionality. These processes communicate with nodes
through the Node Manager API. 

=== Keyserver ===

[[Image(geniportal_v3_keyserver.gif)]]

The Keyserver exposes a private XML-RPC interface for use by other code within the system,
including the website and the Node Manager API. 

The Keyserver maintains all keys. No keys are stored in any other part of the system. When
a public and/or private key needs to be stored, it is stored in the keyserver and a unique
id can then be communicated to the Keyserver XML-RPC Interface to perform actions with the key.

Actions performed by the Keyserver include:
  * Store/delete/retrieve public/private key.
  * Sign data with a private key.
  * Verify data signature with a public key.

Only a few actions will be authorized to be performed when the request comes from the Website.
The method by which the Keyserver determines that a privileged request is authorized is not
specified here for the moment. It may be as simple as a passphrase included with the request. Other security
measures to be taken include only accepting requests from known IPs.

=== Node Manager API ===

The Node Manager API internally makes use of the Keyserver API in order to, for example, obtain
signed data to be communicated to nodes.

----

== Logging ==

Logging will be available in multiple ways:
  * Request/Response available via [http://docs.djangoproject.com/en/dev/topics/http/middleware/ django middleware].
  * Logging at the controller interface will be possible (allows logging requests/response, recording time, etc. independent of frontend -- though much of this may be taken care of by the backend when processing the queue).
  * Use of the python logger module (no calls to "print", ever).
  * Email critical errors to developers (include request/response information).
  * As the queue maintained by the backend will not be deleting processed requests but rather only marking them as completed with their resulting information, this will provide a log in itself.

Ultimately, various logged information should be summarized and available through a website so that the status of the site can be easily monitored. This would include details of exceptions, number of types of requests, average request times for different requests, etc. A summarization/visualization of this data helps to identify logic bugs. For example, there may be no critical exceptions happening but an unusually high percentage of vessel acquisition requests are not able to be fulfilled. Such a situation would be better seen through a summary of results of calls that pass through the controller interface rather than waiting for the bug to be noticed directly.
 
----

== Testing ==

  * Unit tests at various locations:
    * frontends (using [http://docs.djangoproject.com/en/dev/topics/testing/ django test framework])
    * controller interface
    * keyserver
    * backend
    * nodemanager api
  * Test data:
    * make use of [http://docs.djangoproject.com/en/dev/topics/testing/#fixture-loading fixtures in django]
  * Dependency injection to increase testability using mock objects:
    * at least in databases and the Node Manager API so that, for example, other functions that ultimately result in node communication can be tested without actual node communication.

----

== Models ==

'''Note: this section hasn't been updated yet since jsamuel's Monday morning discussion with JAC.'''

The following models are based on the old/current models. Some fields have been changed. The major change is that there is a !VesselUserMap model (a junction/map table) to provide a many-to-many map of vessels to users who have access to those vessels. The old/current models have a !VesselMap which is a map of Users to !VesselPorts (that is, the old/current design has an unnecessary level of indirection between the user record and the vessel record).

JAC: Is the rest of this sensible?   I'd be happier redoing the rest of this as it makes sense.   We will likely end up rewriting much of the code, so the database can be completely changed.   

jsamuel: As far as being sensible, I believe it generally is. There will very likely be yet more fields that are changed/removed/added when this is actually implemented (some of that probably due to my understanding of things growing and realizing there are bits I hadn't previously fully understood). In terms of general structure, though, I'll add here the argument for the basic structure. As long as this is sane, I'm not sure there's a lot of reason for drastically changing the basic db layout.

Basic argument for the model:
  * There are three major objects to be dealt with:
    * users
    * donations/nodes
    * vessels
  * It makes sense to have at least a table for each of these objects. The relationships between them are:
    * each donation/node is donated by a single user
    * each vessel is acquired by a single user
    * each vessel will ultimately be accessible by multiple users
    * each vessel has multiple ports associated with it
  * If there was going to be a keyserver that tracked all keys, then any key references would probably be replaced by a key id.
    * This indirection could be added now in the form of a keys table if needed, but that should be done in a way to ensure minimal code changes will be needed to change over to using a key server.

The details of the models are as follow:
  * User
    * fields:
      * djangouser
        * links this record to the django user record
      * port
      * affiliation
      * pubkey
      * privkey
      * donor_pubkey
      * donor_privkey
      * vessel_count_acquired
        * the number of vessels this user owns
        * this could be figured out through inspection of the vessels table but this scales better and may be used for atomicity of changes to the recorded number of vessels a user owns (without having to lock the vessels table, at least).
      * vessel_credits_via_base
      * vessel_credits_via_donations

  * Donation
    * thoughts:
      * jsamuel: Should this be called a "Node" rather than a "Donation"?
    * fields:
      * donor (foreign key to the users table)
      * pubkey
      * ip
      * port
      * subnet
      * date_added
      * last_heard
      * status
        * the rewrite will ensure that the status field is changed through specific functions to do so, as right now it is done through scattered string arguments. (At the moment I can see 'Initializing', 'Ready', and 'Intermediate' and that is all that appears in the database at the moment, as well.)
      * version
      * epoch
        * jsamuel: I'm not sure the epoch field is needed. it appears to only be used (strangely) in genidb.handle_inactive_donation().
      * active
      * owner_pubkey
      * owner_privkey

  * Vessel
    * fields:
      * donation (foreign key to the donations table)
      * name
      * status
        * there is a documented [https://seattle.cs.washington.edu/wiki/NodeManagerDesign#NodeManagerInterface list of possible status]
        * as with the donation status field, let's keep these updates to specific functions in one place so that we know which statuses are used and can prevent typos. (I actually do see a typo -- 'Intialized' -- in the live database, but I think this much be an old bug as I can't see that string anywhere in the code.)
      * extra_vessel
      * acquired_by_user (foreign key to the users table)
        * if this vessel has been acquired by a user, this is the user who acquired it

  * !VesselPort
    * description:
      * Represents a port that is available on a vessel. A single vessel can have multiple ports (multiple !VesselPort records).
    * fields:
      * vessel (foreign key to vessels table)
      * port
        * the actual port number, not a foreign key to a new "ports" table -- though that would seem technically correct and could be useful in a few rare cases, it feels like it would be over-complication

  * !VesselUserMap
    * description:
      * Represents user access to vessels. This is a many-to-many relationship. The user who acquired the vessel will always have a mapping to that vessel. In the future when additional users can be added to a Vessel through the !GeniPortal, the additional users would have records here.
    * fields:
      * vessel (foreign key to vessels table)
      * user (foreign key to users table)
      * creation_date
      * expiration_date

Indexing
  * The current database schema does not appear to make use of additional indexes for performance.
  * In the above models I haven't discussed specific indexes to be added to tables, but these won't be forgotten.
    * Indexes will be added where logical and should be tested using a large database with performance profiling.

=== Model Notes ===

  * '''Vessel acquisition''': If a user acquires a vessel, the vessel counts towards that user's vessel limit.
  * '''Vessel releasing''': Releasing a vessel means to clear the list of users with access to the node and to return the vessel credit to the user who had acquired the vessel. (The vessel may be reset, etc.)
  * '''Vessel multi-user access''': A vessel can be accessible to multiple users even though it is always acquired by a single user. Whether any user with access to the vessel can release it is not specified here and can be decided later. The simplest initial implementation is probably to allow any user with access the ability to release the vessel, so initial implementation will probably use that approach. (Adding additional users to a vessel may not be available through the UI for this version, but the functionality will be easy to implement.)
  * '''Sharing''': allowing other users to create vessels against your vessel credits is not re-incorporated in the design at this time.
