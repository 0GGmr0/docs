= !SeattleGeni Design Document/Proposal =

This is a proposal for the rewrite of !SeattleGeni. Feedback welcome (e.g. comments here, to jsamuel, or to the list).

[[TOC(inline)]]

----

== Design Goals ==

  * Greater understandability and maintainability.
    * Current design is more difficult than necessary for new people to understand.
  * Easier testing.
    * Current design's lack of modularity makes testing difficult.
  * Better logging.
    * Design not only needs to incorporate better logging, but needs to allow easy future addition of logging.
  * Eliminate race conditions.
    * Current implementation has various race conditions related to database access.
  * Improve security.
    * Minimize the impact of website/webserver compromise.

----

== New Design Plan ==

At a high level, the idea will be to:
  * Redesign the data model to more accurately represent the current (and likely future) data to be stored.
  * Implement a Lockserver that will be used by all other components of the system to ensure mutual exclusion in modification of data and node communication.
  * Rewrite/refactor code for readability, ease of testing, locking, logging, etc.
  * Keep the existing separate Backend server and extend it to handle more data-modifying and node-modifying actions.
  * Move all private keys to a separate Keyserver.
  * Restrict the the Website from performing arbitrary Keyserver requests or signed nodemanager calls.

=== Website ===

[[Image(seattlegeni_website.gif)]]

  * End clients communicate with the Website through either XML-RPC or HTTP.
  * The request's authorization is checked (e.g. ensure valid session for HTTP) and
    the request is then sent through the Controller Interface.
  * The Controller then processes the request based on the type of request.
    * The Controller will handle as much of the work as it can given the limitation that, as it
      is part of the Website, it cannot perform nodemanager calls directly or access arbitrary keys.
      * The Controller will leverage the Backend to perform actions that it cannot perform directly.
        * For example, a request for a user to acquire/release vessels will ultimately require using
          the Backend API in order to perform the required nodemanager calls.
    * A request to download the user's private key, or to delete the user's private key, will go
      through the Keyserver Low-Auth API (the only keyserver API calls that the Website has sufficient
      privileges to execute).
    * The Website will do locking through the Lockserver as needed.

=== Backend ===

[[Image(seattlegeni_backend.gif)]]

  * The Backend performs fundamentally the same purpose as the current backend implementation, which is
    the performing of nodemanager communication indirectly resulting from user requests.
    * This will now have the extra motivation of the fact that the Website will not be able to directly perform nodemanager
      communication.
  * The Backend exposes a private XML-RPC interface for use by other code within the system,
    including the Website and Polling Daemons.
  * The Backend will do locking through the Lockserver as needed.
  * The backend uses a Geni Nodemanager API to do actual node communication. This is just a simple wrapper around the nmclient.

=== Lockserver ===

The Lockserver exposes a private XML-RPC interface for use by other code within the system,
including the Website, Backend, and Polling Daemons. The purpose is to allow client code
to be guaranteed exclusive access to some parts of the system.

The following lock types will exist:
  * ''global''
    * excludes the granting of any other lock
    * there should be few or no cases where this is needed in client code, but could be useful for maintenance tasks, for example.
  * ''user''
    * used for most user-initiated actions to ensure sequential order per-user
    * examples of cases where used:
      * user key change
      * user resource acquisition/release
      * user deletion
  * ''node''
    * can only be obtained if no locks on individual vessels of the node
    * examples of cases where used:
      * node state transition scripts
  * ''vessel''
    * can only be obtained if no locks on the corresponding node
    * examples of cases where used:
      * vessel acquisition/release
      * node state transition scripts
      * user key change
      * could be used in the future to lock the extra vessel if resource allocation to/from the extra vessel is implemented

Lock requests will include one or more identifiers for one or more types of locks. For example, a lock request
may be made for 6 different vessels and one user.

Lock request will be granted sequentially. When some locks are held, subsequent requests for non-conflicting
locking will be granted. When a request is made for a lock that is already held, all subsequent requests will be
queued until the first waiting request can be granted. (Non-conflicting pending requests can't be safely granted
out of order because it might cause starvation of some requests -- at least, it can't be done with simple logic
and we won't attempt to do that.)

Initially the Lockserver will be implemented in the simplest manner possible and client code will only
make use of blocking lock requests. When it is determined to be needed for efficiency or other
reasons, the Lockserver can be extended to allow client code to perform more advanced requests, such as
non-blocking lock requests that will return a lock acquisition failure if the lock can't be granted immediately.

=== Keyserver ===

The Keyserver exposes a private XML-RPC interface for use by other code within the system,
including the website and the Node Manager API. 

The Keyserver maintains all private keys. No keys private are stored in any other part of the system. When
a private key needs to be stored, it is stored in the Keyserver and the corresponding public key can be
communicated to the Keyserver to perform actions involving the private key.

Actions performed by the Keyserver include:
  * Store/delete/retrieve private key.
  * Sign data with a private key.

Only a few actions will be authorized to be performed when the request comes from the Website.
The method by which the Keyserver determines that a privileged request is authorized is not
specified here for the moment. It may be as simple as a passphrase included with the request.

=== Polling Daemons ===

Polling Daemons are any processes or scripts that perform general monitoring of nodes
as well as node state transition functionality. These processes communicate with nodes
directly through the Node Manager API unless there is shared functionality that has
reason to exist in the Backend.

----

== An Example Request Being Handled ==

A user requests new vessels through the website (either through HTTP or XMLRPC).

''In the Website''

The details of the request are passed to the Controller Interface (which is part of the controller, but is the only part of the Controller directly communicated with by the HTTP or XMLRPC frontends).

The Controller sees that the request needs to have a ''user'' lock and obtains one through the Lockserver API (blocking until the lock is obtained).

The Controller determines whether the user is allowed the requested resources (that is, where the user already has too many acquired vessels). If not, the user lock is released and a proper response is returned to the frontend.

The Controller determines whether there are sufficient resources available to fulfill the request and, if so, which resources (e.g. specific vessels) those are. This is done without locking and so there is no guarantee at this point that the resources will be able to be acquired for this user. If there are not sufficient resources, the user lock is released and the proper response is returned to the frontend.

At this point the controller knows a set of vessels it wants to acquire for the user. The Controller repeatedly uses Backend API calls to acquire the needed individual vessels for the user.

''In the Backend''

The Backend receives the request (through its XML-RPC interface) to assign a specific vessel to a specific user.

The Backend obtains a lock for this vessel through the Lockserver API (blocking until the lock is obtained).

Now that the Backend has a lock for this vessel, it uses the Database API to determine if the the vessel is available for assignment to a user (that is, ensure it is not assigned to another user, ensures the correct port for the user exists on the vessel, ensures that the node the vessel is on is considered active, etc.). If the vessel is not available for assignment, the vessel lock is released and a proper response is returned (which in this case is a respionse to the Controller).

The Backend uses the Geni Nodemanager API to perform a !ChangeUser on the vessel. If the call fails, the Backend releases the vessel lock and returns a proper response.

(The Geni Nodemanager API is a simple library that in turn uses the Keyserver API to obtain signed data for the actual nodemanager communication.)

Once the !ChangeUser call to the node is complete, the Backend uses the Database API to update the database to indicate this vessel's assignment to the user. (If the system crashes before this is complete, the user's key will have been set on the vessel but there will be no record of this in the database, so the vessel will retain the user's key until it is assigned to another user, barring cleanup that may take place by outside scripts which detect this issue).

The Backend then releases the lock on the vessel and responds to the Website that the acquisitions was successful.

''In the Website''

The Controller repeats the process of using the Backend to acquire vessels for the user. When acquisitions fail, the Controller does its best to try to accommodate the request until it is no longer possible to fulfill the request. If it is no longer possible to fulfill the request, the Controller makes calls to the Backend to release each vessel that had been successfully acquired.

When the Controller has finished (either by giving up and releasing any acquired vessels or by acquiring the desired vessels), the Controller releases the user lock and returns a proper response to the frontend so that the frontend can give the appropriate response to the request (either HTTP or XML-RPC, however the request came in).

----

== Logging ==

Logging will be available in multiple ways:
  * Request/Response available via [http://docs.djangoproject.com/en/dev/topics/http/middleware/ django middleware].
  * Logging at the controller interface will be possible (allows logging requests/response, recording time, etc. independent of frontend -- though much of this may be taken care of by the backend when processing the queue).
  * Use of the python logger module (no calls to "print", ever).
  * Email critical errors to developers (include request/response information).
  * Lockserver logging requests including how long released locks were held. Potentially notify developers if a lock has been held an unusual amount of time.
  * Keyserver logging all requests.

Ultimately, various logged information should be summarized and available through a website so that the status of the site can be easily monitored. Log files by themselves tend to not be looked at by humans except after something is known to be going wrong. Where possible and efficient, some data may be logged to a database in order to facilitate easy summarization of the data (this wouldn't replace file logging).

Whether logged to a database or text files, a summarization/visualization of log data helps to identify logic bugs or other problems in the system. For example, there may be no critical exceptions happening but an unusually high percentage of vessel acquisition requests are not able to be fulfilled. Such a situation would be better seen through a summary of results of calls that pass through the controller interface rather than waiting for the bug to be noticed directly.
 
----

== Testing ==

  * Unit tests at various locations:
    * frontends (using [http://docs.djangoproject.com/en/dev/topics/testing/ django test framework])
    * Controller
    * Keyserver
    * Lockserver
    * Backend
  * Test data:
    * make use of [http://docs.djangoproject.com/en/dev/topics/testing/#fixture-loading fixtures in django]
  * Dependency injection to increase testability using mock objects:
    * at least in databases and the Node Manager API so that, for example, other functions that ultimately result in node communication can be tested without actual node communication.
    * will not be aiming for idealized testability in design where that conflicts with the coding style of the project (i.e. monkey patching ok if code changes for dependency injection don't fit well)

----

== Database / Data Models ==

It is likely we'll use the django ORM rather than something more full-featured and complex like SQLAlchemy. The benefits of a more complex ORM would largely be for efficiency at the cost of clarity and maintainability. The result of using django's ORM may be more database round trips as well as more frequently resorting to raw SQL but with the code being easier to understand in the common case.

jsamuel: SQLAlchemy would be more fun to use but seems less maintainable by other people as it generally seems less distanced from the underlying data. I'm very open to arguments in favor of SQLAlchemy to justify its use initially. Regarding complex queries and raw SQL, I don't think using the ORM for complex queries actually helps when people aren't experts with the ORM, as it usually takes a long time to write it without SQL and the result can be not what one intended. The models defined below I don't think are complex enough such that they are limited by what django's ORM lacks.

The details of the models (database schemas) are below.

=== Main Database ===

  * User
    * purpose:
      * A User record represents a !SeattleGeni user.
    * fields:
      * djangouser
        * links this record to the django user record
      * usable_vessel_port
        * the port which must be assigned to a vessel for the user to be able to acquire that vessel.
        * this field may go away later on if users are no longer always assigned to the same port on all vessels.
      * affiliation
        * the text the user supplied which identifies the organization they are affiliated with.
      * user_pubkey
        * the corresponding private key, if stored, is stored in the keyserver and is accessible using this public key.
        * a possible efficiency improvement to be implemented if necessary would be to store a flag indicating whether the private key existed. This would prevent the website from having to ask the keyserver anytime we want to be able to prompt the user to download/delete the private key.
      * donor_pubkey
        * the corresponding private key is always stored in the keyserver and is accessible using this public key.
    * notes
      * For efficiency reasons, additional fields may be added to keep cached values for the amount of resources the user has donated and has acquired, rather than requiring calculating this information on demand.

  * Node
    * purpose:
      * A Node record represents an individual nodemanager. When a node goes offline, it is marked inactive. Node records are never deleted because if they were and a node with a delete node's node_identifier came back online, the owner private key would have been lost.
    * fields:
      * node_identifier
        * the node's identifier (which happens to be a public key with no corresponding private key)
      * last_known_ip
        * the ip address the nodemanager was last known to be accessible through.
      * last_known_port
        * the port the nodemanager was last known to be accessible through.
      * last_known_version
        * the version of seattle the node was last known to be running.
      * date_last_contacted
        * the last time the node could be contacted by a monitoring script.
      * is_active
        * the node gets marked as not active when it becomes inaccessible.
      * owner_pubkey
        * the !SeattleGeni's owner key for this node.
         * the private key is always stored in the keyserver and is accessible using this public key.
      * extra_vessel_name
        * the extra vessel will (at least in the near future) have the node's free resources assigned to it, so the name needs to be known in order to do things with those resources.
    * notes
      * The subnet will be calculated as needed rather than stored unless the database impact is too high. If it needs to be saved, it will be an indexed string field. (The current implementation as the concatenated first three octets without periods looks flawed unless I'm reading it wrong).

  * Donation
    * purpose:
      * A Donation record represents the resources a user has donated from a single node.
    * fields:
      * node (foreign key to nodes table)
      * donor (foreign key to the users table)
      * status
        * This field will be used, if necessary, to indicate steps in the process of setting up a donation's resources for use (which, for now, would be creating vessels on the corresponding node using this donation's resources).
      * resource_description_text
        * Simple storage of the contents of a resource file describing the donated resources.
        * This information is not currently used anywhere. How this data is stored may change in the future and this field just serves to start keeping track of the information for now.
    * notes
      * In the future, there may be more than one donor of a node and so multiple Donation records for a single node but each with different donors. For now it will be used as just one donation record per node record.

  * Vessel
    * purpose:
      * A vessel record represents a vessel that !SeattleGeni has setup on a node. Note that this is '''not''' tied to an individual donation of resources from that node.
    * fields:
      * node (foreign key to the nodes table)
      * name
        * the name used to refer to the vessel when communicating with the nodemanager
      * acquired_by_user (foreign key to the users table)
        * if this vessel has been acquired by a user, this is the user who acquired it
      * date_acquired
      * date_expires
        * the date after which the vessel should be taken away from the user who has acquired it.

  * !VesselPort
    * purpose:
      * A !VesselPort record represents a port that is assigned to a vessel. A single vessel can have multiple ports assigned to it (multiple !VesselPort records).
    * fields:
      * vessel (foreign key to vessels table)
      * port

  * !VesselUserAccessMap
    * purpose:
      * A !VesselUserAccessMap record represents user access to vessels. This is a many-to-many relationship. The user who acquired the vessel will always have a mapping to that vessel. In the future when additional users can be added to a Vessel through !SeattleGeni, the additional users would have records here.
    * fields:
      * vessel (foreign key to vessels table)
      * user (foreign key to users table)

There will likely be additional tables for logging.

=== Keyserver Database ===

  * Key
    * purpose:
      * A Key record represents a public/private key pair. Keys are referenced by the public keys themselves. A keypair only needs to be stored here if there is need to store a private key.
    * fields:
      * pubkey
        * the way the client code refers to this key.
      * privkey
        * this will always be set for any record, as there is no reason to only store just a public key.
      * usage_identifier
        * a unique name in the !SeattleGeni system where this key is used. for example, this would identify a given key is a specific user record's donor key.
        * possible example: "user:123:donor" to represent user 123's donor key.
        * this is only for additional consistency checking (e.g. to allow an additional way to look for invalid/unused/missing key mappings) and information purposes, not for authentication in any way. It may end up only being read by separate scripts and never read within the keyserver (only written by the keyserver).
      * allow_unprivileged
        * flag to indicate whether this key is accessible to unprivileged client applications (e.g. the website).
        * if an unprivileged client requests this key (or, possibly just the private key/signing services), the request would be rejected if this flag is not set.

=== Model Notes ===

  * '''Indexing'''
    * The current database schema does not appear to make use of additional indexes for performance.
    * In the above models I haven't discussed specific indexes to be added to tables, but these won't be forgotten. Indexes will be added where logical and should be tested using a large database with performance profiling.
  * '''Vessel acquisition''': If a user acquires a vessel, the vessel counts towards that user's vessel limit. In the future, limits may be by resources (e.g. diskspace) rather than number of vessels.
  * '''Vessel releasing''': Releasing a vessel means to clear the list of users with access to the node and to return the vessel credit to the user who had acquired the vessel. (The vessel may be reset, etc.)
  * '''Vessel multi-user access''': A vessel can be accessible to multiple users even though it is always acquired by a single user. Whether any user with access to the vessel can release it is not specified here and can be decided later. The simplest initial implementation is probably to allow any user with access the ability to release the vessel, so initial implementation will probably use that approach. (Adding additional users to a vessel may not be available through the UI for this version, but the functionality will be easy to implement.)
  * '''Sharing''': allowing other users to create vessels against your available resources is not re-incorporated in the design at this time.
