= !GeniPortal Version 3 Design Document/Proposal =

This is a proposal for the rewrite of the !GeniPortal. Feedback welcome (e.g. comments here, to jsamuel, or to the list).

[[TOC(inline)]]

----

== Design Goals ==

  * Greater understandability and maintainability.
    * Current design is more difficult than necessary for new people to understand.
  * Easier testing.
    * Current design's lack of modularity makes testing difficult.
  * Better logging.
    * Design not only needs to incorporate better logging, but needs to allow easy future addition of logging.
  * Eliminate race conditions.
    * Current implementation has various race conditions related to database access (e.g. I believe the potential for the same key from keys_512 to be assigned to multiple users).
       * JAC: we have a key server that we need to put into place.   It will prevent this from being a problem.
    * It appears to jsamuel that locking at the database level needs to be done in certain situations.
    * JAC: can we create a locking service for the backend?   I.e. you pass it a string it uses a lock name.   This should be easy to implement and seems like a good locking primitive.   We would likely implement this with XMLRPC
  * Eliminate the need for a separate backend xmlrpc server.
    * Current design makes use of a separate xmlrpc server to synchronize some database and nodemanager operations related to vessel assignment.
      * This is an additional potential point of failure.
      * If there were a security argument for this, it could be worth it (e.g. certain keys are not accessible to the !GeniPortal and the backend xmlrpc server that has access to them runs on a different server)
    * If the necessary synchronization can be done without this separate server, it should be.

----

== New Design Plan ==

We'll split the system up into three main components: Frontend, Controller, and Backend.

[[Image(seattlegeni-rewrite-structure.gif)]]

=== Frontend ===

A way in which the !GeniPortal is interacted with. There are separate frontends here (which do not communicate with each other, but rather only with the controller interface). Two planned frontends will be HTML (the website) and XML-RPC.

=== Controller ===

The "middle" between the Frontend and Backend. The brunt of the logic goes here. The various frontends make calls to functions in a single interface module in the controller. These interface functions then directly or indirectly make calls to backend functions.

As an example of what would be in the controller interface, there may be a function

{{{def acquire_vessels(user, count, type):}}}

which would be used by both requests through the HTML frontend as well as the XML-RPC frontend.

=== Backend ===

Where most of the dirty work will be kept for database modification and node communication.

JAC: It may make sense to do locking and key generation here too.

----

== Logging ==

Logging will be available in multiple ways:
  * Request/Response available via [http://docs.djangoproject.com/en/dev/topics/http/middleware/ django middleware].
  * Logging at the controller interface (allows logging requests/response, recording time, etc. independent of frontend).
  * Use of the python logger module (no calls to "print", ever).
  * Email critical errors to developers (include request/response information).

Ultimately, various logged information should be summarized and available through a website so that the status of the site can be easily monitored. This would include details of exceptions, number of types of requests, average request times for different requests, etc. A summarization/visualization of this data helps to identify logic bugs. For example, there may be no critical exceptions happening but an unusually high percentage of vessel acquisition requests are not able to be fulfilled. Such a situation would be better seen through a summary of results of calls that pass through the controller interface rather than waiting for the bug to be noticed directly.
 
----

== Testing ==

  * Unit tests:
    * frontends (using [http://docs.djangoproject.com/en/dev/topics/testing/ django test framework])
    * controller interface
    * controller additional logic
    * backend db
    * backend nodemanager api
  * Test data:
    * make use of [http://docs.djangoproject.com/en/dev/topics/testing/#fixture-loading fixtures in django]
  * Dependency injection to increase testability using mock objects:
    * at least in backend database and nodemanager so that, for example, other functions that ultimately result in node communication can be tested without actual node communication.

----

== Models ==

The following models are based on the old/current models. Some fields have been changed. The major change is that there is a !VesselUserMap model (a junction/map table) to provide a many-to-many map of vessels to users who have access to those vessels. The old/current models have a !VesselMap which is a map of Users to !VesselPorts (that is, the old/current design has an unnecessary level of indirection between the user record and the vessel record).

JAC: Is the rest of this sensible?   I'd be happier redoing the rest of this as it makes sense.   We will likely end up rewriting much of the code, so the database can be completely changed.   

jsamuel: As far as being sensible, I believe it generally is. There will very likely be yet more fields that are changed/removed/added when this is actually implemented (some of that probably due to my understanding of things growing and realizing there are bits I hadn't previously fully understood). In terms of general structure, though, I'll add here the argument for the basic structure. As long as this is sane, I'm not sure there's a lot of reason for drastically changing the basic db layout.

Basic argument for the model:
  * There are three major objects to be dealt with:
    * users
    * donations/nodes
    * vessels
  * It makes sense to have at least a table for each of these objects. The relationships between them are:
    * each donation/node is donated by a single user
    * each vessel is acquired by a single user
    * each vessel will ultimately be accessible by multiple users
    * each vessel has multiple ports associated with it
  * If there was going to be a keyserver that tracked all keys, then any key references would probably be replaced by a key id.
    * This indirection could be added now in the form of a keys table if needed, but that should be done in a way to ensure minimal code changes will be needed to change over to using a key server.

The details of the models are as follow:
  * User
    * fields:
      * djangouser
        * links this record to the django user record
      * port
      * affiliation
      * pubkey
      * privkey
      * donor_pubkey
      * donor_privkey
      * vessel_count_acquired
        * the number of vessels this user owns
        * this could be figured out through inspection of the vessels table but this scales better and may be used for atomicity of changes to the recorded number of vessels a user owns (without having to lock the vessels table, at least).
      * vessel_credits_via_base
      * vessel_credits_via_donations

  * Donation
    * thoughts:
      * jsamuel: Should this be called a "Node" rather than a "Donation"?
    * fields:
      * donor (foreign key to the users table)
      * pubkey
      * ip
      * port
      * subnet
      * date_added
      * last_heard
      * status
        * the rewrite will ensure that the status field is changed through specific functions to do so, as right now it is done through scattered string arguments. (At the moment I can see 'Initializing', 'Ready', and 'Intermediate' and that is all that appears in the database at the moment, as well.)
      * version
      * epoch
        * jsamuel: I'm not sure the epoch field is needed. it appears to only be used (strangely) in genidb.handle_inactive_donation().
      * active
      * owner_pubkey
      * owner_privkey

  * Vessel
    * fields:
      * donation (foreign key to the donations table)
      * name
      * status
        * there is a documented [https://seattle.cs.washington.edu/wiki/NodeManagerDesign#NodeManagerInterface list of possible status]
        * as with the donation status field, let's keep these updates to specific functions in one place so that we know which statuses are used and can prevent typos. (I actually do see a typo -- 'Intialized' -- in the live database, but I think this much be an old bug as I can't see that string anywhere in the code.)
      * extra_vessel
      * acquired_by_user (foreign key to the users table)
        * if this vessel has been acquired by a user, this is the user who acquired it

  * !VesselPort
    * description:
      * Represents a port that is available on a vessel. A single vessel can have multiple ports (multiple !VesselPort records).
    * fields:
      * vessel (foreign key to vessels table)
      * port
        * the actual port number, not a foreign key to a new "ports" table -- though that would seem technically correct and could be useful in a few rare cases, it feels like it would be over-complication

  * !VesselUserMap
    * description:
      * Represents user access to vessels. This is a many-to-many relationship. The user who acquired the vessel will always have a mapping to that vessel. In the future when additional users can be added to a Vessel through the !GeniPortal, the additional users would have records here.
    * fields:
      * vessel (foreign key to vessels table)
      * user (foreign key to users table)
      * creation_date
      * expiration_date

Indexing
  * The current database schema does not appear to make use of additional indexes for performance.
  * In the above models I haven't discussed specific indexes to be added to tables, but these won't be forgotten.
    * Indexes will be added where logical and should be tested using a large database with performance profiling.

=== Model Notes ===

  * '''Vessel acquisition''': If a user acquires a vessel, the vessel counts towards that user's vessel limit.
  * '''Vessel releasing''': Releasing a vessel means to clear the list of users with access to the node and to return the vessel credit to the user who had acquired the vessel. (The vessel may be reset, etc.)
  * '''Vessel multi-user access''': A vessel can be accessible to multiple users even though it is always acquired by a single user. Whether any user with access to the vessel can release it is not specified here and can be decided later. The simplest initial implementation is probably to allow any user with access the ability to release the vessel, so initial implementation will probably use that approach. (Adding additional users to a vessel may not be available through the UI for this version, but the functionality will be easy to implement.)
  * '''Sharing''': allowing other users to create vessels against your vessel credits is not re-incorporated in the design at this time.

----

== Synchronization ==

As the website is not a sole single-threaded process, there can be conflict with two different process trying to modify related data in the database. Database transactions don't address this issue (two transactions can happily update the same data not knowing the other was updating it -- transactions aren't a locking mechanism).

With the dual goals of taking care to eliminate race conditions that result from multi-threaded database access as well as eliminating the need for a separate backend server, this version of the !GeniPortal will use database locking mechanisms to provide mutual exclusion as needed.

This will take some good design and planning. jsamuel is by no means an expert here, but he feels that it is likely possible to do the required database locking and, as a result, end up with a more robust system. The difficult parts will be:
  * Ensure that the exclusion/locking is done correctly to avoid race conditions as well as deadlock.
  * Avoid excessive performance penalties (e.g. avoid exclusive table locks except when absolutely necessary and then only very briefly, avoid excessive row locking and unlocking, etc.)

Correctness will be the major goal with performance focused more heavily on later. This is not only for the sake of getting something working sooner rather than later, but also to help identify earlier if this approach will not work.

'''Important note''': If in development there appear to be too many difficulties in implementing this correctly using database locking, the use of a separate single-process multi-threaded backend xmlrpc server (as is currently used) will be reconsidered. A working solution that more people understand is better than a non-working one (or even a working one) that is only maintainable by the person who wrote it. However, use of a separate backend server will be avoided, if possible, at it also has issues (such as a tendency for code not in the backed xmlrpc server to ignore race conditions with database access).

----

== Fundamental change idea: Make vessel-modifying actions asynchronous ==

This would be to:
  * improve scalability
  * have greater control over the complexity of synchronization/locking that needs to be implemented
  * simplify the role of the website.

Some actions that would be performed asynchronously would include:
  * Request/release vessels
  * Add user to vessels
  * Change user key

Actions that would not be performed asynchronously (they would be fulfilled in real-time) include:
  * All queries for data that do not make changes.
  * Data updates that do not involve remote communication and in no way impact the fulfilling of asynchronously fulfilled actions.
    * Examples: create new user. delete user private key.

=== How it could be done ===

  * Keep a table of user actions 
    * When a request is made, perform checks that don't require vessel communication.
      * If the request is potentially fillable, return an action_id to the user (xmlrpc) or
        notify them that their request is pending and have the interface 
        check for updates (html).
      * If the request could not possibly be filled (e.g. user does not have enough
        vessel credits, there are not enough resources of the type requested), indicate that in the response.
        * Denying a request due to lack of resources available does allow the possibility that a request for vessels
          is denied when there are pending vessel release requests that have not been processed, but such a situation
          seems acceptable.
    * Could be multiple tables, not a single request table (a more complex db structure, but much cleaner data):
      * simple request table that tracks only id, request_time, request_type
      * separate table for each request_type that holds request/result data for that
        request type.
  * Have a daemon process to process the action queue
    * Can run on a different server from the web server
    * Could initially process a single action at a time for correctness/simplicity.
      * If number of requests was ever great enough, could be changed to perform
        some actions simultaneously, some with higher priority, etc.
        * Examples:
          * Process vessel releases before vessel requests.
          * Process multiple vessel release actions simultaneously.
          * Process multiple vessel request actions simultaneously.
  * Clients would interact with the frontend as follows:
    * xmlrpc asynchronous
      * Request resources.
      * Receive response of QUEUED with an action_id, or FAILED with a reason.
      * If QUEUED, client can then make status requests using the action_id.
    * xmlrpc synchronous requests
      * This could be implemented, if needed, by just having the frontend wait until
        the response has been fulfilled before responding.
    * html
      * Request resources.
      * Show result of pending or failed.
      * If pending, either manual refreshing or ajax-based to check status.

