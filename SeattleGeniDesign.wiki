= Design Goals =

  * Greater understandability and maintainability.
    * Current design is more difficult than necessary for new people to understand.
  * Easier testing.
    * Current design's lack of modularity makes testing difficult.
  * Better logging.
    * Design not only needs to incorporate better logging, but needs to allow easy future addition of logging.
  * Eliminate race conditions.
    * Current implementation has various race conditions related to database access (e.g. I believe the potential for the same key from keys_512 to be assigned to multiple users).
    * It is likely that locking at the database level needs to be done in certain situations.
  * Eliminate the need for a separate backend xmlrpc server.
    * Current design makes use of a separate xmlrpc server to synchronize some database and nodemanager operations related to vessel assignment.
      * This is an additional potential point of failure.
      * If there were a security argument for this, it could be worth it (e.g. certain keys are not accessible to the !GeniPortal and the backend xmlrpc server that has access to them runs on a different server)
    * If the necessary synchronization can be done without this separate server, it should be.

= New Design Plan =

We'll split the system up into three main components: Frontends, Controller, and Backend.

[[Image(seattlegeni-rewrite-structure.gif)]]

== Frontends ==

A way in which the !GeniPortal is interacted with. Two planned frontends will be HTML (the website) and XML-RPC.

== Controller ==

The "middle" between the Frontend and Backend. The brunt of the logic goes here. The various frontends make calls to functions in a single interface module in the controller. These interface functions then directly or indirectly make calls to backend functions.

== Backend ==

Where most of the dirty work will be kept for database modification and node communication.

= Logging =

Logging will be available in multiple ways:
  * Request/Response available via [http://docs.djangoproject.com/en/dev/topics/http/middleware/ django middleware].
  * Logging at the controller interface (allows logging requests/response, recording time, etc. independent of frontend).
  * Use of the python logger module (no calls to "print", ever).
  * Email critical errors to developers (include request/response information).

Ultimately, various logged information should be summarized and available through a website so that the status of the site can be easily monitored. This would include details of exceptions, number of types of requests, average request times for different requests, etc.
 
= Testing =

  * Unit tests:
    * frontends (using [http://docs.djangoproject.com/en/dev/topics/testing/ django test framework])
    * controller interface
    * controller additional logic
    * backend db
    * backend nodemanager api
  * Test data:
    * make use of [http://docs.djangoproject.com/en/dev/topics/testing/#fixture-loading fixtures in django]
  * Dependency injection to increase testability using mock objects:
    * at least in backend database and nodemanager so that, for example, other functions that ultimately result in node communication can be tested without actual node communication.

= Models =

  * User
    * fields:
      * djangouser
        * links this record to the django user record
      * port
      * affiliation
      * pubkey
      * privkey
      * donor_pubkey
      * donor_privkey
      * vessel_count_acquired
        * the is the number of vessels this user owns
        * this could be figured out through inspection of the vessels table but this scales better and may be used for atomicity of changes to the recorded number of vessels a user owns (without having to lock the vessels table, at least).
      * vessel_credits_via_base
      * vessel_credits_via_donations
      * vessel_credits_via_shares

  * Donation
    * thoughts:
      * Should this be called a "Node" rather than a "Donation"?
    * fields:
      * user
      * pubkey
      * ip
      * port
      * subnet
      * date_added
      * last_heard
      * status
        * the rewrite will ensure that the status field is changed through specific functions to do so, as right now it is done through scattered string arguments. (At the moment I can see 'Initializing' and 'Ready', not sure if there are others.)
      * version
      * epoch
        * jsamuel: I'm not sure the epoch field is needed. it appears to only be used strangely in genidb.handle_inactive_donation().
      * active
      * owner_pubkey
      * owner_privkey

  * Vessel
    * fields:
      * donation
      * name
      * status
        * there is a documented [https://seattle.cs.washington.edu/wiki/NodeManagerDesign#NodeManagerInterface list of possible status]
        * as with the donation status field, let's keep these updates to specific functions in one place so that we know which statuses are used and can prevent typos.
      * extra_vessel
      * acquired_by_user
        * if this vessel has been acquired by a user, this is the user who acquired it

  * !VesselPort
    * description:
      * Represents a port that is available on a vessel. A single vessel can have multiple ports (multiple !VesselPort records).
    * fields:
      * vessel
      * port

  * !VesselUserMap
    * description:
      * Represents user access to vessels. This is a many-to-many relationship. The user who acquired the vessel will always have a mapping to that vessel. In the future when additional users can be added to a Vessel through the !GeniPortal, the additional users would have records here.
    * fields:
      * vessel
      * user
      * creation_date
      * expiration_date

== Model Notes ==

  * '''Vessel acquisition''': If a user acquires a vessel, the vessel counts towards that user's vessel limit.
  * '''Vessel releasing''': Releasing a vessel means to clear the list of users with access to the node and to return the vessel credit to the user who had acquired the vessel. (The vessel may be reset, etc.)
  * '''Vessel multi-user access''': A vessel can be accessible to multiple users even though it is always acquired by a single user. Whether any user with access to the vessel can release it is not specified here and can be decided later. The simplest initial implementation is probably to allow any user with access the ability to release the vessel, so initial implementation will probably use that approach. (Adding additional users to a vessel may not be available through the UI for this version, but the functionality will be easy to implement.)
  * '''Sharing''': allowing other users to create vessels against your vessel credits is not re-incorporated in the design at this time.

= Synchronization =

As the website is not a sole single-threaded process, there can be conflict with two different process trying to modify related data in the database. Database transactions don't address this issue (two transactions can happily update the same data not knowing the other was updating it -- transactions aren't a locking mechanism).

With the dual goals of taking care to eliminate race conditions that result from multi-threaded database access as well as eliminating the need for a separate backend server, this version of the !GeniPortal will use database locking mechanisms to provide mutual exclusion as needed.

This will take some good design and planning. Justin S. is by no means an expert here, but he feels that it is likely possible to do the required database locking and, as a result, end up with a more robust system as a result. The difficult parts will be:
  * Ensure that the exclusion/locking is done correctly to avoid race conditions as well as deadlock.
  * Avoid excessive performance penalties (e.g. avoid exclusive table locks except when absolutely necessary and then only very briefly, avoid excessive row locking and unlocking, etc.)

Correctness will be the major goal with performance focused more heavily on later. This is not only for the sake of getting something working sooner rather than later, but also to help identify earlier if this approach will not be work.

'''Important note''': If in development there appear to be too many difficulties in implementing this correctly using database locking, the use of a separate single-process multi-threaded backend xmlrpc server (as is currently used) will be reconsidered. A working solution that more people understand is better than a non-working one (or even a working one) that is only maintainable by the person who wrote it. However, use of a separate backend server will be avoided, if possible, at it also has issues (such as a tendency for code not in the backed xmlrpc server to ignore race conditions with database access).
