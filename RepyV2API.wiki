= Future Repy Library Reference = 

----
[[TOC(inline)]]
----

For a detailed description of Network API call semantics see: [NetworkApiSemantics].  (Read the description of calls on this page first.)

[[BR]]
== Introduction and Purpose ==
----

This document describes the narrow API available to repy programs.   This document includes all of the calls that are available to a repy program and the use and meaning of these calls.   For items built into the python programming language (like list operations, etc.) see the appropriate Python documentation.   

The intent is that we will build libraries that will provide 'rich' functionality on top of these abstractions.   For example, the file-like objects don't support next, but we can build this in a library.   Also, notice that the logging mechanism doesn't support multiple arguments / do type conversion.   We can do this in a user level library.   We will expect that all users will load this library (and may even do it for them).



[[BR]]
== Cheat Sheet ==
----

||Variable Name||Short description||Tutorial Section||
||callargs||callargs are the command line arguments for your program (similar to Python's sys.argv[1:])||example 2.2||
||callfunc||callfunc is a string that indicates if the program was called for initialization or exit.||example 1.1||
||mycontext||mycontext is a shared dictionary that is used in place of global variables.||example 1.3||

[[BR]]

||Object Name||Short description||Tutorial Section||

||file||similar to Python's file object||example 2.1||

||socket||similar to Python's socket object||example 1.2||

||lock||similar to Python's threading.Lock object||example 1.6||



[[BR]]

||Object / Function Name||Short description||Tutorial Section||

||file.readat||Read data from a file (maybe seek first).||N/A (new call)||

||file.writeat||Write data to a file (maybe seek first).||N/A (new call)||

||file.close||Close an open file.||example 2.1||

||socket.recv||Read data from a socket||example 1.2||

||socket.send||Send data on a socket||example 1.2||

||socket.close||Closes a socket||example 3.2||

||socket.willblock||Returns an indicator of whether or not a socket will block|| N/A (new call)||

||lock.acquire||Acquire the lock||example 1.6||

||lock.release||Release the lock||example 1.6||


[[BR]]

||Function Name||Short description||Tutorial Section||

||safeopen||opens file objects. ||example 2.1||

||listdir||similar to Python's os.listdir() function||example 2.2||

||removefile||similar to Python's os.remove() function||example 2.2||

||sleep||similar to Python's time.sleep() function||example 1.6||

||randombytes||similar to Python's os.urandom() function||(new call) example 4.2||

||getlock||similar to Python's threading.Lock() constructor||example 1.6||

||exitall||similar to Python's sys.exit() or os._exit()||example 3.2||

||getruntime||gets the time since the program was started||example 1.4||

||gethostbyname_ex||similar to Python's socket.gethostbyname_ex() function||example 4.1||

||getmyip||gets an external IP address of the computer||example 4.1||

||registermessagecallback||registers a function to be called on message receipt (callback)||example 4.2||

||sendmessage||sends a message to another computer||example 4.2||

||openconnection||opens a connection to another computer (blocking)||example 3.1||

||registerconnectioncallback||registers a function to be called when a connection is opened ||example 1.2||

||deregistercallback||removes either a connection or message based callback (blocking)||example 1.2||

||settimer||sets a thread to execute at a time in the future (callback)||example 1.4||

||canceltimer||cancels an thread that has not yet started||example 1.5||

||circularlog||logs information to the circular logging buffer (replaces print)||example 1.1||

||getthreadname||provides a unique string that indicates the name of the current thread||New call||




[[BR]]
== Detailed description ==
----


[[BR]]
=== Shared variables ===
----

[[BR]]
==== mycontext ====
----

    Mycontext is a dictionary that is shared between all of the threads in your program. The intent is that mycontext will be used in the place of global variables. See the tutorial for examples using mycontext.

[[BR]]
==== callfunc ====
----
    Your program may choose to have different functionality that executes at different times.   The callfunc variable is set to values that indicate what the state of execution is.   Callfunc is set to either "initialize" and "exit".   These are executed by running the program as a script and setting the variable callfunc to either the string "initialize" or the string "exit".   The "initialize" is the first time that your program executes.   If initialize finishes and there are no pending threads or callbacks, the program is called with "exit" to allow it a chance to clean up.

[[BR]]
==== callargs ====
----

    Callargs is a list of strings that contain the arguments your program was called with.   If there are no arguments, callargs contains an empty list.


[[BR]]
=== API functions ===
----

      
[[BR]] 
==== gethostbyname_ex(name) ====
----
(from the Python documentation)   Translate a host name to IPv4 address format, extended interface. Return a triple (hostname, aliaslist, ipaddrlist) where hostname is the primary host name responding to the given ip_address, aliaslist is a (possibly empty) list of alternative host names for the same address, and ipaddrlist is a list of IPv4 addresses for the same interface on the same host (often but not always a single address). gethostbyname_ex() does not support IPv6 name resolution, and getaddrinfo() should be used instead for IPv4/v6 dual stack support. 

 * Doc string:

   <Purpose>
      Provides information about a hostname.   Calls socket.gethostbyname_ex()

   <Arguments>
      name:
         The host name to get information about

   <Exceptions>
      As from socket.gethostbyname_ex()

   <Side Effects>
      None.

   <Returns>
      A tuple containing (hostname, aliaslist, ipaddrlist).   See the 
      python docs for socket.gethostbyname_ex()

[[BR]]
==== getmyip() ====
----
Returns the localhost's "Internet facing" IP address.   It may raise an exception on hosts that are not connected to the Internet.


 * Doc string:

   <Purpose>
      Provides the external IP of this computer.   Does some clever trickery.

   <Arguments>
      None

   <Exceptions>
      Exception if the host is not connected to the Internet or has name resolution problems

   <Side Effects>
      None.

   <Returns>
      The localhost's IP address

[[BR]]
==== registermessagecallback(localip, localport, function) ====
----

(rename of ~~recvmess~~)

Registers a function as a callback for incoming UDP messages.  If another message arrives before the first is processed, a second thread will be started. If this function is called multiple times on the same ip and port, the previous function is replaced.   When an incoming UDP message is delivered on this IP and port, the function is called.   If there is no free thread / event, the function is not called until a thread / event is available.   Also, if there is no current function registered, an thread / event is consumed to check for incoming network traffic.   This function returns a commhandle that can be used by deregistercallback to deregister the handler.

 * Doc string:

   <Purpose>
      Registers a function as a callback for incoming messages

   <Arguments>
      localip:
         The local IP or hostname to register the handler on
      localport:
         The port to listen on
      function:
         The function that messages should be delivered to.   It should expect
         the following arguments: (remoteIP, remoteport, message, commhandle)

   <Exceptions>
      None.

   <Side Effects>
      Registers a callback.

   <Returns>
      The commhandle for this callback.

[[BR]]
==== sendmessage(desthost, destport, message, localip=None, localport=None) ====
----

(rename of ~~sendmess~~)

Sends a UDP message to a destination host / port.   By default the system selects a localip and port for the outgoing message, but this can be overridden by passing in arguments that specify which port and IP to use.   If either the localip or localport are used, both must be.   Returns the number of bytes sent.

 * Doc string:

   <Purpose>
      Send a message to a host / port

   <Arguments>
      desthost:
         The host to send a message to
      destport:
         The port to send the message to
      message:
         The message to send
      localhost (optional):
         The local IP to send the message from 
      localport (optional):
         The local port to send the message from 

      Note: if you specify localhost, you must specify localport

   <Exceptions>
      socket.error when communication errors happen

   <Side Effects>
      None.

   <Returns>
      The number of bytes sent on success

[[BR]]
==== openconnection(desthost, destport, localip=None, localport=None, timeout = 5) ====
----

(rename of ~~openconn~~)

Open a TCP connection to a remote computer, returning a socket object.   Optionally a localip and localport to connect from can be specified and if one is specified both must be.   There is a timeout value that can be set to limit the amount of time the system will wait for a response before abandoning the attempt to connect.

 * Doc string:

   <Purpose>
      Opens a connection, returning a socket-like object

   <Arguments>
      desthost:
         The host to open communications with
      destport:
         The port to use for communication
      localip (optional):
         The local ip to use for the communication
      localport (optional):
         The local port to use for communication
      timeout (optional):
         The maximum amount of time to wait to connect

      Note: if you specify localip, you must specify localport

   <Exceptions>
      As from socket.connect, etc.

   <Side Effects>
      None.

   <Returns>
      A socket-like object that can be used for communication.   Use send, 
      recv, and close just like you would an actual socket object in python.


[[BR]]
==== registerconnectioncallback(localip, localport, function) ====
----

(similar to ~~waitforconn~~, but the thiscommhandle argument is removed from the callback function)

Register a function to be called whenever a connection is made to a localip and localport (usually TCP).   Multiple instances of the callback may execute concurrently if there are multiple incoming connections.   As with registermessagecallback, an event / thread is consumed to start a network listener if no previous function was registered for either registermessagecallback or registerconnectioncallback.   If a connection is established but no free events / threads remain, the function is not called until one is available.   Returns a handle that can be used by deregistercallback to deregister the function.

 * Doc string:

   <Purpose>
      Waits for a connection to a port.   Calls function with a socket-like 
      object if it succeeds.

   <Arguments>
      localip:
         The local IP to listen on
      localport:
         The local port to bind to
      function:
         The function to call.   It should take four arguments:
         (remoteip, remoteport, socketlikeobj, listencommhandle)
         If your function has an uncaught exception, the program will be terminated.
         
   <Exceptions>
      None.

   <Side Effects>
      Sets up a callback to receive connections.

   <Returns>
      A handle to the callback.   This can be used to deregister the callback.



[[BR]]
==== deregistercallback(commhandle) ====
----

(replaces ~~stopcomm~~, however this no longer functions like close for a connected socket)

Deregisters a callback.   This deregisters the function and if there are no remaining functions registers, stops the event / thread that checks for network traffic.   

 * Doc string:

   <Purpose>
      Deregister a callback for a commhandle.   This works for both message and
      connection based callbacks.

   <Arguments>
      commhandle:
         A commhandle as is returned by registermessagecallback or registerconnectioncallback.

   <Exceptions>
      None.

   <Side Effects>
      None.

   <Returns>
      None.


[[BR]]
==== safeopen(filename, writeable=False, create=False) ====
----

(Replaces: ~~open~~, ~~file~~.)

Open a file, returning an object of the file type. If the file cannot be opened, IOError is raised.

Filenames may only be in the current directory and contain letters, numbers, the hyphen, underscore, and period character and may not be '.' or '..'.   There is no concept of a directory or a folder in repy.  

The writeable parameter determines whether the file handle is read-only or capable of both reading and writing. Neither mode truncates the file on open.

If create is True, the file is created if it does not exist.

 * Doc string:

     <Purpose>
        Allows the user program to open a file safely.   This function is not
        meant to resemble the builtin "open".

     <Arguments>
        filename:
           The file that should be operated on
        writeable:
           The mode:
              False:  Open the file for reading.
              True: Open the file for reading and writing.

              Note: files are always opened in "binary" mode.
        create:
           If True, create the file if it doesn't exist already.

     <Exceptions>
        As with open, this may raise a number of errors.

     <Side Effects>
        Opens a file on disk, using a file descriptor.

     <Returns>
        A file-like object.


[[BR]]
==== file.close() ====
----

Close the file. A closed file cannot be read or written any more. Any operation which requires that the file be open will raise a ValueError after the file has been closed. Calling close() more than once is allowed.

 * Doc string:

   <Purpose>
      Allows the user program to close a file.  This function is meant
      to resemble the builtin "file.close".

   <Arguments>
      None.

   <Exceptions>
      None.

   <Side Effects>
      Closes a file descriptor previously opened for writing.

   <Returns>
      Nothing.

[[BR]]
==== file.readat(size=None, offset=None) ====
----

If offset is an integer, first seek to that location in the file. (If it is omitted or None, no seek is performed.)

Reads up to size bytes of the rest of the (open) file, returning what is read. If size is omitted or None, the file is read to EOF.

 * Doc string:

   <Purpose>
      Reads from a file handle.

   <Arguments>
      size (optional) - Specify a maximum number of bytes to read from the
                        file.

      offset (optional) - Seek to a specific location in the file before
                          reading.

   <Exceptions>
      ValueError if the file is closed.
      TypeError if offset or size is not an integer.

   <Side Effects>
      Seeks to offset (if specified) and advances the file pointer by the
      number of bytes read.

   <Returns>
      The data that was read; this may be the empty string only if we
      have reached the end of the file or size was non-positive.

[[BR]]
==== file.writeat(data, offset=None) ====
----

If offset is an integer, first seek to that location in the file. (If it is omitted or None, no seek is performed.)

Write some data to a file.

 * Doc string:

   <Purpose>
      Allows the user program to write data to a file (and optionally
      seek somewhere first).

   <Arguments>
      Data to write (a string).

      Offset (optional) - where to seek in the file first.

   <Exceptions>
      ValueError if the file is closed.
      IOError if the disk is out of space or some low level IO error occurs.
      TypeError if offset isn't an integer or data isn't a string.

   <Side Effects>
      If offset is included, seeks to offset.

      Writes some data after the current filepointer position, advancing it.

   <Returns>
      Nothing.

[[BR]]
==== listdir() ====
----


Returns a list of file names for the files in the vessel.   

 * Doc string:

   <Purpose>
      Allows the user program to get a list of files in their area.

   <Arguments>
      None

   <Exceptions>
      This probably shouldn't raise any errors / exceptions so long as the
      node manager isn't buggy.

   <Side Effects>
      None

   <Returns>
      A list of strings (file names)

[[BR]]
==== removefile(filename) ====
----

Deletes a file in the vessel.   If the file does not exist, an exception is raised.

 * Doc string:

   <Purpose>
      Allows the user program to remove a file in their area.

   <Arguments>
      filename: the name of the file to remove.   It must not contain
      characters other than 'a-zA-Z0-9.-_' and cannot be '.' or '..'

   <Exceptions>
      An exception is raised if the file does not exist

   <Side Effects>
      None

   <Returns>
      None

[[BR]]
==== exitall() ====
----

Terminates the program immediately.   The program will not execute the "exit" callfunc or finally blocks.

 * Doc string:

   <Purpose>
      Allows the user program to stop execution of the program without
      passing an exit to the main program or calling finally blocks.

   <Arguments>
      None.

   <Exceptions>
      None.

   <Side Effects>
      Interactions with timers and connection / message receiving functions 
      are undefined.   These functions may be called after exit and may 
      have undefined state.

   <Returns>
      None.   The current thread does not resume after exit

[[BR]]
==== getlock() ====
----

Returns a lock object that can be used for mutual exclusion and critical section protection.

 * Doc string:


   <Purpose>
      Returns a lock object to the user program.    A lock object supports
      two functions: acquire and release.   See threading.Lock() for details

   <Arguments>
      None.

   <Exceptions>
      None.

   <Side Effects>
      None.

   <Returns>
      The lock object.

[[BR]]
==== lock.acquire(blocking=1) ====
----

Blocks until the lock is available, then takes it (lock is an object obtained by calling getlock()).

If the optional "blocking" argument is False, the method returns False immediately instead of waiting to acquire the lock; if the lock is available it takes it and returns True, as if it were called with no argument.

 * Doc string:


   <Purpose>
      Acquires a lock.

   <Arguments>
      blocking (optional) - if False, returns immediately instead of waiting to acquire the lock.

   <Exceptions>
      None.

   <Side Effects>
      Locks the object.

   <Returns>
      True if the lock was acquired, False otherwise.

[[BR]]
==== lock.release() ====
----

Releases the lock. Do not call it if the lock is unlocked.

 * Doc string:


   <Purpose>
      Release a lock.

   <Arguments>
      None.

   <Exceptions>
      thread.error if release() is called on an unlocked lock.

   <Side Effects>
      Unlocks the object.

   <Returns>
      None.

[[BR]]
==== getruntime() ====
----

Returns a float containing the number of seconds the program has been running.   Note that in very rare circumstances (like the user resetting their clock), this will not produce increasing values.   For the actual time, use NTP (e.g. look in /seattlelib/time.repy for more information in the Seattle SVN trunk).

 * Doc string:


   <Purpose>
      Return the amount of time the program has been running.   This is in
      wall clock time.   This function is not guaranteed to always return
      increasing values due to NTP, etc.

   <Arguments>
      None

   <Exceptions>
      None.

   <Side Effects>
      None

   <Returns>
      The elapsed time as float

[[BR]]
==== randombytes(num) ====
----

Returns a random string of random bytes of data derived from a hardware source of randomness.   The size of the string will be equal to the parameter num.

 * Doc string:


   <Purpose>
      Return a random string of bytes of length num

   <Arguments>
      num: a number of bytes to return

   <Exceptions>
      TypeError if num isn't a long or int

   <Side Effects>
      This function is metered because it may involve using a hardware
      source of randomness.

   <Returns>
      The string of bytes.

[[BR]]
==== settimer(waittime, function, args) ====
----

Sets a timer that when it expires will start a new thread to call a function with a set of arguments.   The thread is charged to your program when you set the timer (instead of when the timer fires).   This function returns a timer handle that may be used to cancel the timer before the thread is started.   

 * Doc string:


   <Purpose>
      Allow the current thread to set an thread to be performed in the future.
      This does not guarantee the thread will be triggered at that time, only
      that it will be triggered after that time.

   <Arguments>
      waittime:
         The minimum amount of time to wait before delivering the thread
      function:
         The function to call
      args:
         The arguments to pass to the function.   This should be a tuple or 
         list

   <Exceptions>
      None.

   <Side Effects>
      None.

   <Returns>
      A timer handle, for use with canceltimer

[[BR]]
==== canceltimer(timerhandle) ====
----

Try to cancels a timer handle that has not started a thread.   Returns False if the thread has been started already (and so cannot be canceled).   Returns True if the timer was successfully canceled.


 * Doc string:


   <Purpose>
      Cancels a timer.

   <Arguments>
      timerhandle:
         The handle of the timer that should be stopped.   Handles are 
         returned by settimer

   <Exceptions>
      None.

   <Side Effects>
      None.

   <Returns>
      If False is returned, the timer already fired or was cancelled 
      previously.   If True is returned, the timer was cancelled




[[BR]]
==== sleep(seconds) ====
----

Sleeps the current thread for some time (waits for a specific time before executing any further instructions).   This thread will not consume CPU cycles during this time.    Timing issues that confuse getruntime() may also cause sleep to behave in undefined ways.

 * Doc string:


   <Purpose>
      Allow the current thread to pause execution (similar to time.sleep()).
      This function will not return early for any reason

   <Arguments>
      seconds:
         The number of seconds to sleep.   This can be a floating point value

   <Exceptions>
      None.

   <Side Effects>
      None.

   <Returns>
      None.


[[BR]] 
==== socket.close() ====
----
Closes the socket.   Any further local calls to recv / send will result in an exception.

 * Doc string:

   <Purpose>
     Closes a socket.   Pending remote recv() calls will return with the
     remaining information.   Local recv / send calls will fail after this.

   <Arguments>
     None

   <Exceptions>
     None

   <Side Effects>
     Pending local recv calls will either return or have an exception.

   <Returns>
     True if this is the first close call to this socket, False otherwise.




[[BR]] 
==== socket.recv(numbytes) ====
----
Receives data that was sent by the connected party using send.   Note that this may return less than bytes worth of data.   Also, note that if the other party does {{{s.send('hello'); s.send('Guten Tag')}}}, the other party who calls recv may get 'helloGuten Tag', 'h', or any other subset of the total data.   If recv returns !'' then the other side has closed the connection.

 * Doc string:

   <Purpose>
     Receives data from a socket.   It may receive fewer bytes than
     requested.

   <Arguments>
     numbytes:
        The maximum number of bytes to read.   

   <Exceptions>
     Exception if the socket is closed either locally or remotely.

   <Side Effects>
     This call will block the thread until the other side calls send.

   <Returns>
     The data received from the socket (as a string).   If !'' is returned,
     the other side has closed the socket and no more data will arrive.

[[BR]] 
==== socket.send(message) ====
----

Sends data to the connected party.   Note that this may send less than the entire message.   If the connection is disconnected, there is no guarantee that the other party was able to recv the data.  If the other party doesn't call recv, send may block indefinitely.   If the other party closes the connection, send will raise an exception.

 * Doc string:


   <Purpose>
     Sends data on a socket.   It may send fewer bytes than requested.

   <Arguments>
     message:
       The string to send.

   <Exceptions>
     Exception if the socket is closed either locally or remotely.

   <Side Effects>
     This call may block the thread until the other side calls recv.

   <Returns>
     The number of bytes sent.   Be sure not to assume this is always the
     complete amount!


[[BR]] 
==== socket.willblock() ====
----

(added call)

Returns a tuple of booleans {{{(recvwillblock,sendwillblock)}}} indicating if a socket may block if send or recv are called.   This allows the caller to determine if a deadlock may occur if the call is performed.   Note that returning True doesn't necessarily mean the call will block.   It could be that data was recently consumed / sent so the call will now proceed without blocking.

 * Doc string:

   <Purpose>
     Determines if a socket may block if send or recv are called.

   <Arguments>
     None.

   <Exceptions>
     Exception if the socket is closed locally or if the socket was
     closed remotely and there is no data pending for recv.

   <Side Effects>
     None.

   <Returns>
     A tuple (recvwillblock, sendwillblock) of booleans.   

[[BR]] 
==== circularlog(string) ====
----

(added call -- replaces ~~print~~)

Writes a string to the circular logging buffer.   A library will be added that constructs a function that log(*args) on top of this.

 * Doc string:

   <Purpose>
     Writes data to the circular logging buffer.

   <Arguments>
     The string to write out.

   <Exceptions>
     Type error if the string argument isn't a string.

   <Side Effects>
     The data is written to the circular logging buffer.

   <Returns>
     None.   

[[BR]] 
==== getthreadname() ====
----

(added call)

Returns a unique name that indicates the thread's name.   Don't use this to derive any meaning other than string uniqueness.
 * Doc string:

   <Purpose>
     Returns a string identifier for the currently executing thread.
     This identifier is unique to this thread.

   <Arguments>
     None.

   <Exceptions>
     None.

   <Side Effects>
     None.

   <Returns>
     A string identifier.

