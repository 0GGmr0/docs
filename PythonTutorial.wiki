= All of the Python you need to understand Repy (and none you don't) =
[[TOC]]

= Introduction =

    This tutorial is written for those who have background knowledge of object oriented programming languages such as C++ and Java. This tutorial focuses on introducing the subset of Python used in the REPY (Restricted Python) language supported by the Seattle testbed.   After reading this tutorial, you should walk through the repy tutorial (link).

= 1. Overview =

== 1-1. Interpreted rather than being compiled == 

You don't have to compile your python code to execute. 

Here is a very simple code to print ‘Hello World’.

{{{
#!python
print “Hello, World”
}}}

You can make a file ‘test.py’ that contains one sentence above, and then run the program by typing

python test.py

It is the normal way to execute the python codes. But this tutorial is written for those who use REPY.
So, we need to explain how to run the codes in REPY.

=== 1-1.1. Executing programs locally in REPY ===

You can run the program above in your computer, but you need different way to execute the program in repy.Maybe this should say "There are two ways to execute a program, locally (useful for debugging) or on remote computers (how you'll actually deploy your programs).   We first explain how to run a program locally" -Justincappos 10/21/08 4:25 PM 

{{{
#!python
python repy.py restrictions.test test.py
}}}

We need to make sure that you have the files named repy.py and restrictions.test in your current directory before executing the program like above.

Output is following

{{{
#!python
Hello World
Hello World
Terminated
}}}

"Hello World" was printed twice, and then the last sentence means that the program was terminated successfully Not all users will see "Terminated"   This only shows up on some operating systems.   Other operating systems have different messages -Justincappos 10/21/08 4:27 PM . test.py is called two times for different events (initialize and exit), because REPY is a event-driven programming language and has two events when it is executed. We can have more detail about it in REPY tutorial. Maybe this talk about events is confusing?  Perhaps we can skip this and instead start with the below example?  -Justincappos 10/21/08 4:28 PM 

If you want to print "Hello World" only one time, you can change the code like below:

{{{
#!python
if callfunc == 'initialize':
    print "Hello World"
}}}

=== 1-1.2. Executing programs remotely in vessels. ===
You can also access the resources donated to you and run the program test.py in the resources you can control. You need to follow the steps below in the shell in order to  run the program in resources.

'''Step 1. Run programs in the Seattle 

To run a program, you should use the experiment manager seash.   Seash allows you to control the files running in sandboxes you control.
python seash.py 

'''Step 2. Log in with my ID

Before logging in, you have to load your public and private keys. You need to make sure that you have two files containing your public and private key. The name of files is your ID and extension of files are publickey and privatekey.
For example, if your ID were john, the two files would be john.publickey and john.privatekey.

If you successfully logged in, you could notice that the prompt starts with you ID.

{{{
#!python
!> loadkeys john
!> as john
john@ !>
}}}

'''Step 3. Locate the resources(computers) you can use

{{{
#!python
john@ !> browse

Added targets: %1(10.0.1.1:1224:v9), %2(10.0.1.2:2888:v9)

Added group 'browsegood' with 2 targets

The command browse produced the output that shows resources(targets) you can control. 
}}}

In the first target %1(10.0.1.1:1224:v9), %1 is the alias of the target, 10.0.1.1 is IP address, 1224 is port number, and v9 is vessel name. The vessel is the partial portion of whole donated resources. It means that the donated resources could be one vessel or divided and assigned to more than one person. 

'''Step 4. Access the resources(vessels)

{{{
#!python
john@ !> on browsegood
}}}

'''Step 5. Run a program

We assume the program named test.py is stored in the current directory, which prints "Hello, World".

{{{
#!python
john@browsegood !> run test.py
}}}

'''Step 6. Look up the result of the program executed

{{{
#!python
john@browsegood !> show log

Log from '10.0.1.1:1224:v9':
Hello World

Log from '10.0.1.2:2888:v9':
Hello World
}}}

'''Step 7. Look up the information about the vessel you control

{{{
#!python
john@browsegood !> list

ID Own       Name          Status          Owner Information
%1  *   10.0.1.1:1224:v9 Terminated                               
%2  *   10.0.1.2:2888:v9 Terminated        
}}}

'''Step 8. Exit from REPY

{{{
#!python
john@browsegood !> exit
}}}

Help command helps you look up the commands you can use in repy.                  

=== 1-1.3. Testing programs in the interactive mode. ===

Instead of executing this program from the command line in batch mode, you could enter and run the code in interactive mode.

Although Repy doesn't have the interactive mode, and uses different function names from regular python, you can test only simple function operations in the interactive mode.

{{{
#!python
% python

>>> print “Hello, World”

Hello, World

>>>
}}}

While in interactive mode, you can test your simple code before executing and look up the command history by using the arrow keys.
To exit interactive mode, hit ctrl-d. Different on different OSes... -Justincappos 10/21/08 4:30 PM 


== 1-2. Non-restricted type ==
Type is not declared in Python. However, the Python interpreter keeps track of the type of all objects. Thus Python variables don’t have types, but their values do.

{{{
#!python
x = 10*10 
print x
x = “Hello”
print x
}}}

Result
{{{
#!python
100
Hello
}}}

== 1-3. High-level operations ==

Python contains many high level operations.

Here is a simple example that print the number of words in ‘Hello Word”

print len(“Hello World”.split())
Result: 2

The method split() is a member of the string class. It splits a string into a list of words and len() returns the number of elements in a list.


= 2. Basic Grammar =

== 2-1. Block Definition ==

{{{
#!python
for i in range(10):
     print i
}}}

In C++ and Java, we use curly braces({}) as a block definition, but in Python, it has different syntax.

The first line should ends with '''colon(:)''' and from next line, lines should be '''indented''' until at the end of the block.

In the example code, range() function returns a list of consecutive integers. This will result in 10 iterations of the loop, 0 through 9.



== 2-2. Flow Control ==

=== 2-2.1 if Statements ===

Perhaps the most well-known statement type is the if statement. For example:

{{{
#!python
x = 42
if x < 0:
    x = 0
    print ’Negative changed to zero’
elif x == 0:
    print ’Zero’
elif x == 1:
    print ’Single’
else:
    print ’More’
}}}

Result
{{{
#!python
More
}}}

There can be zero or more elif parts, and the else part is optional. The keyword ‘elif‘ is short for ‘else if’, and is useful to avoid excessive indentation. An if ... elif ... elif ... sequence is a substitute for the switch or case statements found in other languages.

=== 2-2.2 for Statements ===

The for statement in Python differs a bit from what you may be used to in C or Pascal. Rather than always iterating over an arithmetic progression of numbers (like in Pascal), or giving the user the ability to define both the iteration step and halting condition (as C), Python’s for statement iterates over the items of any sequence (a list or a string), in the order that they appear in the sequence. For example (no pun intended):

{{{
#!python
a = [’cat’, ’window’, ’defenestrate’]
for x in a:
    print x, len(x)
}}}

Result
{{{
#!python
cat 3
window 6
defenestrate 12
}}}

=== 2-2.3 break and continue Statements, and else Clauses on Loops ===

The break statement, like in C, breaks out of the smallest enclosing for or while loop.
The continue statement, also borrowed from C, continues with the next iteration of the loop.
Loop statements may have an else clause; it is executed when the loop terminates through exhaustion of the list (with for) or when the condition becomes false (with while), but not when the loop is terminated by a break statement.

This is exemplified by the following loop, which searches for prime numbers:

{{{
#!python
for n in range(2, 10):
    for x in range(2, n):
        if n % x == 0:
            print n, ’equals’, x, ’*’, n/x
            break
    else:
        # loop fell through without finding a factor
        print n, ’is a prime number’
}}}

Result
{{{
#!python
2 is a prime number
3 is a prime number
4 equals 2 * 2
5 is a prime number
6 equals 2 * 3
7 is a prime number
8 equals 2 * 4
9 equals 3 * 3
}}}

=== 2-3. Function Definition (def) ===
{{{
#!python
def square(x):
    return x*x
}}}

The keyword def is used to define a function. Note once again that the colon and indenting are used to define a block which serves as the function body. A function can return a value, using the return statement. However, the function does not have a type even if it does return something, and the object returned could be anything—an integer, a list, or whatever.


=== 2-4. Reading and Writing Files ===

open() returns a file object, and is most commonly used with two arguments: open(filename, mode).

{{{
#!python
f = open(’/tmp/workfile’, ’w’)
}}}

The first argument is a string containing the filename. The second argument is another string containing a few characters describing the way in which the file will be used. mode can be ’r’ when the file will only be read, ’w’ for only writing (an existing file with the same name will be erased), and ’a’ opens the file for appending; any data written to the file is automatically added to the end. ’r+’ opens the file for both reading and writing. The mode argument is optional; ’r’ will be assumed if it’s omitted.

When you’re done with a file, call f.close() to close it and free up any system resources taken up by the open file. After calling f.close(), attempts to use the file object will automatically fail.


= 3. Sequences =

Sequences are array-like but with some differences.

== 3-1. Lists ==

Lists are denoted by brackets and commas.

There are some useful list operations.
{{{
#!python
x = [1, 2]
}}}

{{{
#!python
x.append(3)

Result: 
[1, 2, 3]
}}}

{{{
#!python
x[0]

Result:
1

x[-1]

Result:
3
}}}
Python array has not only the same indexing structure as other languages but also backward indexing(negative indexing).

In the example above,

||      Value     ||  1  ||  2  ||  3  ||
|| Positive Index ||  0  ||  1  ||  2  ||
|| Negative Index || -3  || -2  || -1  ||


[[BR]]

{{{
#!python
x.extend([-4, 5])

Result: 
[1, 2, 3, -4, 5]
}}}

{{{
#!python
del x[2]

Result: 
[1, 2, -4, 5]
}}}

{{{
#!python
x.remove(5)

Result: 
[1, 2, -4]
}}}

{{{
#!python
z = x[1:3] # array "slicing": elements 1 through 3-1 = 2

Result: 
[2, -4]
}}}

{{{
#!python
x[1:] # all elements starting with index 3

Result: 
[2, -4]
}}}

{{{
#!python
x[:2] # all elements up to but excluding index 2

Result: 
[1, 2]
}}}

{{{
#!python
x.index(-4)

Result: 
2
}}}

{{{
#!python
2 in x

Result: 
True
}}}

{{{
#!python
x = 10
y = 20
[x, y] = [x, y]

Result: 
x = 20, y =10
}}} 

Somewhere in here, we should have negative indices (i.e. x[-1] is the last element) -Justincappos 10/21/08 4:53 PM 

== 3-2. Tuples ==

Tuples are like lists, but are immutable, i.e. unchangeable. They are enclosed by parentheses or nothing at all, rather than brackets. The parentheses are mandatory if there is an ambiguity without them, e.g. in function arguments. A comma must be used in the case of empty or single tuple, e.g. (,) and (5,).

The same operations can be used, except those which would change the tuple. So for example

{{{
#!python
x = (1,2,’abc’)
print x[1] # prints 2
print len(x) # prints 3
x.pop() # illegal, due to immutability
}}}

== 3-3. Strings ==

Strings are essentially tuples of character elements. But they are quoted instead of surrounded by parentheses, and have more ﬂexibility than tuples of character elements would have.

{{{
#!python
x = ‘abcde’
x[2]

Result:
‘c’
}}}

{{{
#!python
x = x[0:3] + ‘z’ + x[3:5]

Result: 
‘abczde’
}}}


== 3-4. Dictionaries (Hashes) ==

Dictionaries are associative arrays. The statement

{{{
#!python
x = {’abc’:12,’sailing’:’away’}
}}}

sets x to what amounts to a 2-element array with x[’abc’] being 12 and x[’sailing’] equal to ’away’. We say that ’abc’ and ’sailing’ are keys, and 12 and ’away’ are values. Keys can be any immmutable object, i.e. numbers, tuples or strings.16 Use of tuples as keys is quite common in Python applications, and you should keep in mind that this valuable tool is available.

Internal storage is organized as a hash table. This is why Perl’s analog of Python’s dictionary concept is actually called a hash.

Here are examples of usage of some of the member functions of the dictionary class:

{{{
#!python
x = {’abc’:12,’sailing’:’away’}
}}}

{{{
#!python
x[’abc’]

Result:
12
}}}

{{{
#!python
y = x.keys()

Result: 
[’abc’, ’sailing’]
}}}

{{{
#!python
z = x.values()

Result: 
[12, ’away’]
}}}

{{{
#!python
x[’uv’] = 2

Result: 
{’abc’: 12, ’uv’: 2, ’sailing’: ’away’}
}}}

= 4. Class =

== 4-1. Structure ==
The keyword ‘self’ is analogous to this in C++ and Java.
Static variables in Python is ‘class name.variable name’.
The constructor for a class is __init__().

== 4-2. Sample Class ==

{{{
#!python
class Complex:
    count = 0
    def __init__(self, realpart, imagpart):
        Complex.count += 1
        self.r = realpart
        self.i = imagpart
}}}

== 4-3. Derived Classes ==

'''superclass.__init__(self)''' 

If a class b is the subclass of a class a, we need write it like,

{{{
#!python
class b(a):
    def __init__(self,xinit): # constructor for class b
        self.x = xinit # define and initialize an instance variable x
        a.__init__(self) # call base class constructor
}}}


= 5. Exception Handling =

Python’s built-in and library functions have no C-style error return code to check to see whether they succeeded. Instead, you use Python’s try/except exception-handling mechanism, e.g.

{{{
#!python
try:
    f = open(callargs[0])
except:
    print ’open failed:’, callargs[0]
}}}

Here’s another example:

{{{
#!python
try:
    i = 5
    y = x[i]
except:
    print ’no such index:’, i
}}}

But the Python idiom also uses this for code which is not acting in an exception context. Say for example we want to find the index of the number 8 in the list z and if there is no such number, to first add it to the list. We could do it this way:

{{{
#!python
try:
    place = x.index(8)
except:
    x.append(8)
    place = len(x)
}}}

The try statement has another optional clause which is intended to define clean-up actions that must be executed under all circumstances. A finally clause is always executed before leaving the try statement, whether an exception has occurred or not. For example:

{{{
#!python
def divide(x, y):
    try:
        result = x / y
    except ZeroDivisionError:
        print "division by zero!"
    else:
        print "result is", result
    finally:
        print "executing finally clause"
}}}

Results are following

{{{
#!python
divide(2, 1)
result is 2
executing finally clause

divide(2, 0)
division by zero!
executing finally clause

divide("2", "1")
executing finally clause
Traceback (most recent call last):
File "<stdin>", line 1, in ?
File "<stdin>", line 3, in divide
TypeError: unsupported operand type(s) for /: ’str’ and ’str’
}}}

As you can see, the finally clause is executed in any event.

