= Build Instructions =
This page guides you through the build process for the repositories at [https://github.com/SeattleTestbed Seattle Testbed's GitHub page]. The first section discusses what is required to get hold of a repo and build it so that it can be run. The second section describes how to run unit tests. The last part explains how our initialize and build scripts work behind the scenes.

----
[[TOC(inline)]]
----

== Building components ==
This section describes how to build components from their source repositories on [https://github.com/SeattleTestbed GitHub].
Currently, these components have been set up to be buildable and runnable: `seash`, `repy_v2`, `overlord`, and `experimentmanager`. The other components can be built for unit test mode (see below).

'''Note:''' Overlord and Experiment Manager are currently being ported to RepyV2 and will not fully work.[[BR]]


1. Clone the repository that you want to build from [https://github.com/SeattleTestbed SeattleTestbed]. Be sure to check out the `new_build_v1` branch of the repository, as the new build scripts haven't been merged to the master branch yet.[[BR]]
For example, if you are building [wiki:SeattleShell seash], do: 
{{{
#!sh
$ git clone -b new_build_v1 https://github.com/SeattleTestbed/seash
}}}
Of course, you will want to replace `seash` with the repository name you are interested in.

2. This yields a folder named like the repository you cloned. Inside of it, there is a `scripts` folder which in turn contains a script called `initialize` to fetch the dependencies of this component. Continuing with our example `seash`:[[BR]]
{{{
#!sh
cd seash/scripts
./initialize
}}}
`initialize` Git-clones the dependent repositories into `DEPENDENCIES` directory which will be a sub-directory inside your main repository . It will make use of `config_initialize.txt` to fetch the list of dependencies.[[BR]]

3. Once done with that, you will find `DEPENDENCIES` directory created as a sub-directory inside your main repository. It contains all the cloned dependencies. Inside `DEPENDENCIES`, there is a sub-directory named `common` which contains the actual build script, `build.py`. Before calling it, you have the option to set up a target folder for the build. But this step is '''optional''':
{{{
#!sh
mkdir TARGET_FOLDER
}}}
If you don't setup a target directory, `build.py` will itself create a target folder named `RUNNABLE` which will be a sub-directory inside your main repository (`COMPONENT/RUNNABLE`).[[BR]]

4. If you haven't implemented the previous optional step, then you don't need to change your current working directory, which is `COMPONENT/scripts`. Run the `build` script as:
{{{
#!sh
./build
}}}
But if you created the target folder earlier (as mentioned in '''Step -3 '''), you have the option to give it the absolute path to your desired target folder.
{{{
#!sh
cd COMPONENT/scripts
./build /absolute/path/to/TARGET_FOLDER
}}}
'''Note:''' Make sure you change your working directory to `COMPONENT/scripts` before running `build`.[[BR]]
`build` will copy all the files necessary to build the particular Seattle Component into the target directory. It will make use of 'config_build.txt' in order to fetch the list of files and directories to copy to target.[[BR]]

'''Done! ''' Your target folder now contains a runnable version of the component! [[BR]]



== Building and Running Unit Tests ==
When making changes to the code (or build scripts!) you will want to ensure that the change does not have side effects or breaks functionality that had been working before. In order to ensure this, each component comes with a set of ''unit tests''.

The steps of the previous section intrinsically downloaded the required unit test files. You just need to run the build script again to create a ''testable'' build. Use the `-t` command line option to indicate you want the test files to be included:
{{{
#!sh
mkdir TEST_TARGET_DIR
cd COMPONENT/scripts
./build -t 
}}}
or
{{{
#!sh
mkdir TEST_TARGET_DIR
cd COMPONENT/scripts/dist
./build -t /absolute/path/to/TEST_TARGET_DIR
}}}

Then, change to the test target directory (which will either be `RUNNABLE` or `TEST_TARGET_DIR` of your choice that you created) and start the unit tests:
{{{
#!sh
cd ../RUNNABLE
python utf.py -a
}}}

The unit test framework prints out the test name and result (plus debugging information if available), e.g.:
{{{
	Running: ut_nm_addfiletovessel.r2py                         [ PASS ]
}}}

[[BR]]


== How The Build Process Works ==

The new Seattle build procedure makes use of two scripts, `initialize` and `build`, and two sets of configuration instructions, `config_initialize.txt` and `config_build.txt`.

`config_initialize.txt` provides `initialize` with Git links to dependent repositories. `initialize` then Git-clones from there. Usually, we link to our main repositories, [https://github.com/SeattleTestbed github/SeattleTestbed], but linking to other repos is common during development. Note that links may include branch or commit specifiers so as to enable release management ("tagging").

`config_build.txt` provides `build` with the names and paths of necessary files that are to be copied over from the cloned repos to the target directory to build the required Seattle component.

A sample `config_initialize.txt` looks like this:
 {{{
# These are custominstallerbuilder's dependencies. They are essentially 
# everything that is required to build a Seattle base installer (including 
# support for RepyV1 and RepyV2, a nodemanager, Affix, and a softwareupdater).
https://github.com/SeattleTestbed/repy_v1 DEPENDENCIES/repy_v1
https://github.com/SeattleTestbed/repy_v2 DEPENDENCIES/repy_v2
https://github.com/SeattleTestbed/seattlelib_v1 DEPENDENCIES/seattlelib_v1
https://github.com/SeattleTestbed/seattlelib_v2 DEPENDENCIES/seattlelib_v2
https://github.com/SeattleTestbed/nodemanager DEPENDENCIES/nodemanager
https://github.com/SeattleTestbed/softwareupdater DEPENDENCIES/softwareupdater
https://github.com/SeattleTestbed/portability DEPENDENCIES/portability
https://github.com/SeattleTestbed/common DEPENDENCIES/common
https://github.com/aaaaalbert/affix.git -b minimal-clean-alpha-release DEPENDENCIES/affix
https://github.com/SeattleTestbed/clearinghouse DEPENDENCIES/clearinghouse
https://github.com/aaaaalbert/seash.git -b sync-with-affix-alpha-release DEPENDENCIES/seash
https://github.com/SeattleTestbed/resource.git DEPENDENCIES/resource
}}}

Here is the corresponding {{{config_build.txt}}}:
{{{
# Build file for the Repy runtime that the custominstallerbuilder requires. 
# (Essentially identical with repy_v2's config_build.txt).
repy_v2/*
portability/*
seattlelib_v2/*
seash/*
clearinghouse/xmlrpc_clients/seattleclearinghouse_xmlrpc.py
affix/*
affix/components/*
}}}


One can add comments to the configuration files by prefixing lines with `#`. [[BR]]
Within `config_build.txt`, lines starting with `test ` specify the test files (or file patterns) that are copied over to the target directory if the build script is called in test mode (`build.py -t target_dir`). 

Example:
{{{
repy_v2/*
portability/*
seattlelib_v2/*
seash/*
clearinghouse/*
# Tests
test ../testsV2/*
}}}



The required directory layout for a repository supporting this build method is this:

{{{
the_component/     # Repo base directory, includes code etc.
the_component/scripts/
the_component/scripts/initialize
the_component/scripts/build
the_component/scripts/config_initialize.txt
the_component/scripts/config_build.txt
the_component/DEPENDENCIES/common/build.py
}}}

'''Note:''' The `/DEPENDENCIES/common/build.py` is not part of `scripts/`. Running `initialize` clones the dependent repositories into `the_component/DEPENDENCIES` and clones the `common` repository which contains `build.py`. You don't have to specially run `build.py` script. The script `the_component/scripts/build` indirectly runs `build.py` and takes care of it.