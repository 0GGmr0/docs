= Using Sensors In Seattle =

A Seattle / Repy program cannot access resources like GPS, wifi signal strength information, motion sensors, etc.   However, many users would like to provide information about resources like this to researchers.   To facilitate the exchange of information, we provide an API that sensor applications (installed separately from Seattle) can use to make the sensor available to local Repy programs.

[[TOC(inline)]]

== Overview ==

The API that is provided by sensors may vary significantly from application to application.   The philosophy is to provide an API that is as simple as possible but would allow a variety of sensor applications to operate.   We intentionally under constrain the interface to make it as easy as possible to use in the base case.   Further parts of this document describe how to do slightly more advanced functionality while providing this API.

== Required API ==

All sensors must provide an XMLRPC interface bound to 127.0.0.1 on any port from 63090-63099.   This XMLRPC interface must support at least the following two calls:  {{{isSeattleSensor()}}}, {{{system.listMethods()}}}, and {{{system.methodSignature}}}.   (See [http://docs.python.org/library/simplexmlrpcserver.html the SimpleXMLRPCAPI] for general details on Python, but similar libraries exist on other platforms.)   The {{{isSeattleSensor()}}} call must return True.   The {{{system.listMethods()}}} should list the available calls.   The {{{system.methodSignature(callname)}}} must return the calling arguments for a function.

'''Note: it is completely fine for a sensor to hide calls it does not want to be called by general clients.'''   In other words, if you have a call that performs a potentially disruptive act, you need not list it.   Keep in mind that this is not a security mechanism.   It is just to prevent a simple and general client from calling it without understanding what it does.

It is also *recommended* that you provide the call {{{system.methodHelp}}}.   This is not required and clients *must not* rely on their existence.

== Example Use ==

Here is some example pseudo-code for building a sensor and client.   

Sensor code:

{{{
import SimpleXMLRPCServer
import socket
import sys

for sensorport in [63095, 63096, 63097, 63098, 63099, 63090, 63091, 63092, 63093, 63094]:
  try:
    server = SimpleXMLRPCServer(("localhost", sensorport),
                            requestHandler=RequestHandler)
    server.register_introspection_functions()
  except socket.error:
    print 'port:',sensorport,'failed.   Trying backup port...' 
    continue
  break
else:
  print 'Could not locate a port!'
  sys.exit(1)
    
import iwlistlib


def isSeattleSensor():
  return True

# NOTE: the system.* calls are defined by the !SimpleXMLRPCServer in Python.   Your library's use may vary.

def mySensorName():
  return "Hello World Sensor"

def readSensor():
  return "Hello World!"

def readSensorForLanguage(language):
  if language == 'English':
    return "Hello World!"
  elif language == 'German':
    return "Hallo Weld!"
  elif language == 'Mandarin':
    return "Ni Hao!"
  else:
    raise Exception("Unsupported language")


server.register_introspection_functions()
server.register_function(mySensorName)
server.register_function(readSensor)
server.register_function(readSensorForLanguage)
server.register_function(isSeattleSensor)

server.serve_forever()

}}}


Repy sensor reading code:
{{{
import xmlrpclib
import sys

# I really should check multiple ports...
s = xmlrpclib.ServerProxy('http://localhost:63095')

# should check the error status...
try: 
  if not s.isSeattleSensor():
    print 'something other than a Seattle sensor was bound to the port...'
    sys.exit(1)
except:
    print 'Got an error when checking if this is a Seattle sensor...'
    sys.exit(1)
  
# Get the list of available methods
methodlist = s.system.listMethods()

for methodname in methodlist:
  thissignature = s.system.methodSignature(methodname)
  print 'Method:',methodname,'has the signature', thissignature

  if thissignature == ():
    print 'Empty call returns:',safe_eval("s."+methodname+"()")

}}}


Note: I didn't test the above code!   Beware of bugs!!!