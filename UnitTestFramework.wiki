= Seattle's Unit Test Framework Alpha Documentation =

----
[[TOC(inline)]]
----

[[BR]]
== Abstract ==
----
The purpose of this document is to outline the most important features and to gather as much feedback as possible with respect to the new testing framework. We will be referring to Testing Unit Framework as UTF.

Please feel free to add any comments or concerns at the bottom of the page.

[[BR]]
== Requirements ==
----
Before diving into design and examples, I would like to specify requirements, so that the users have a better understanding of what the goals are. 

 * Above everything, writing a unit test module should be simple and obvious for new users.
 * Test module should be able to have many small test cases and developer should be able to group them into test suites.
 * The framework should allow advanced users to perform non-trivial tests.
 * The framework should allow users to easily select what tests to run (whole module or specific test cases).
 * The framework back-end needs to be simple and extensible.

When translating requirements into objectives, we are faced with a non-trivial task, since some requirements are more important than others. As a result, advanced features are somewhat limited (for instance there is not support for test trees).

[[BR]]
== Design ==
----
UTF behaves similarly to python's standard unittest library, with addition of several other features suitable for Seattle. Those are:

 * Testing within '''Repy execution environment'''.
 * Ability to specify different '''restrictions''' for different Repy test files.
 * Testing for '''standard out and standard error''' messages.
 * Support for '''setup and shutdown scripts'''.

Having this in mind, you are probably asking yourself: 'Well, how do I achieve this?'. Obviously, we need to be able to hint or to instruct the framework about our needs. Those instructions are embedded '''either in the file itself or the filename'''. Below, we discuss each aspect.

When instructing the UTF:

 * that the test file is suppose to be run inside the Repy execution environment,
 * or to use a non-default restrictions file,
 * or that the executed test has to produce a specific output on standard out or/and standard error

we need to use the following syntax withing the:

{{{
#!python

#DIRECTIVE TYPE [ARGS]
}}}

The directive name is always going to be '''pragma''' (a directive communicating additional "pragmatic" or implementation-specific information). Therefore, the more specific syntax is:

{{{
#!python

#pragma TYPE [ARGS]
}}}

The following #pragma directives are allowed. When an unknown #pragma directive is encountered, UTF reports an error.

{{{
#!python
"""
Instructs UTF that this test file is suppose to be run inside Repy execution environment. 
Restriction file argument is optional -- if not specified restrictions.default is used.
If this directives is omitted, UTF assumes that your test file is a standard Python
file.
"""
#pragma repy [RESTRICTIONS FILE]

"""
Instructs UTF that this test file is suppose to produce some output on standard out. 
If the TEXT argument is specified, UTF will try to find TEXT substring within standard out. 
If TEXT is not specified, UTF makes sure that the standard out data is not empty.
"""
#pragma out [TEXT]

"""
Instructs UTF that this test file is suppose to produce some output on standard error. 
If the TEXT argument is specified, UTF tries to find TEXT substring within standard error. 
If TEXT is not specified, UTF makes sure that the standard error data is not empty.
"""
#pragma error [TEXT]
}}}

[[BR]]
----
[[BR]]

Other features are encoded inside of the ''' filename'''. Those are:

 * Which module does the test file belong to.
 * Does the module have setup and shutdown scripts?
 * Whether or not the test file will be executed by default.

All test files have to follow a strict naming convention: 

{{{
#!python

ut_<module name>_<descriptor>.py.
}}}

A module can have multiple test files associated with it.

Furthermore, a module may contain two special descriptors: '''setup''' and '''shutdown'''. When running full module testing, ut_<module>_setup.py is executed at the '''beginning''' and ut_<module>_shutdown.py at the '''end''' of the execution. This is primarily used by more complicated modules, which require initialization and clean-up steps.

Test files with the above mentioned syntax are executed '''by default'''. To exclude them from default execution, '''prepend the filename with _'''. This way, the test file has to be executed '''explicitly'''.

[[BR]]
----
[[BR]]

When running tests, a developer is presented with three different possibilities:
 * Run all tests for all modules:

{{{
#!python

$ utf.py

}}}

 * Run all tests for a specific module

{{{
#!python

$ utf.py --module <module name>
$ utf.py -m <module name>

}}}

 * Run a specific test file.

{{{
#!python

$ utf.py --file <file>
$ utf.py -f <file>

}}}

[[BR]]
== Examples ==
----
Now, let us go over some simple and straightforward examples. Each of the examples is intended to provide a use case for a specific feature.

[[BR]]
=== Python Testing ===
----
So, you are writing a piece of software whose API has been defined and maybe implemented, and now you would like to start testing its behaviour.

The component you are testing is a resource monitor. For the sake of simplicity, there are only few methods implemented.

{{{
#!python

def add_host(host_name): ...
def list_hosts(): ...
}}}

First thing you need to do is create a test file. If you have read the previous section, you will remember that each test file has to follow a specific naming convention. Everything that you will be writing for Seattle is a smaller component (or a module) of the entire Seattle framework. Thus, we need to give it an appropriate name. Let's go ahead and create that file.

{{{
#!python

vim ut_monitor.py
}}}

Now, we start writing test cases. You write them the same way you would any python executable. The only thing to remember is that by default your test file is not allowed to produce any output (stdout or stderr).

{{{
#!python

# import you module.
import monitor

# Test valid host names.
def test_valid_add():

  valid_host_names = ('google.com', 
                      '128.208.1.1', 
                      '127.0.0.1')
  
  for host_name in valid_host_names:
    add_host(host_name)

  Available_hosts = list_hosts()
  if len(available_hosts) != len(valid_host_names):
    print 'Adding valid host names failed.'



def test_invalid_add():

  invalid_host_names = ('...', '0.0.0.0')
  for host_name in invalid_host_names:
    try: add_host(host_name)
    except: InvalidHostName
    else: print 'Adding invalid host did not raise an exception'

}}}

All you have to do now is run the UTF, specifying ''monitor'' as the module to test.

{{{
#!python

$ utf.py -m monitor
Testing module: monitor
  Running ut_monitor.py                   [ PASS }

$
}}}

----

After some time, you decide that you need to add additional functionality to you resource monitor component (i. e. Disk Usage). As you would imagine, you test file could get bloated pretty quickly, so you decide to split module testing into multiple test files. Remember, all of the files have to be in the same module, but need to have a different descriptor. The purpose of the descriptor is to give a general description of what the file is testing.

{{{
#!python

# Resource Monitor -- Host Availability.
$ mv ut_monitor.py ut_monitor_hosts.py

# Resource Monitor -- Disk Usage.
$ vim ut_monitor_disk.py

}}}

After you're done writing test cases for the new functionality, simply run UTF once more.

{{{
#!python

$ utf.py -m monitor
Testing module: monitor
  Running ut_monitor_hosts.py               [ PASS }
  Running ut_monitor_disk.py                [ PASS }
$
}}}


[[BR]]
=== Repy Testing ===
----
When doing Repy testing, there are two distinct aspects:
 * Testing Repy Libraries.
 * Testing Repy Execution Environment.

==== Repy Libraries ====
Testing a library ought to be simple. Image you are writing a synchronization primitive (semaphore) which has four methods defined.

{{{
#!python

def create_semaphore(): ...
def destroy_semaphore(handle): ...
def up(handle): ...
def down(handle): ...
}}}

Accordingly, we need to create a test file for it.

{{{
#!python

# The module name is repy.semaphore.
vim ut_repy.sempahore
}}}

The first thing we must do is instruct the testing framework that this file is suppose to be executed inside of the Repy Execution Environment (NOTE: This might change in the near future. Need further discussion.). This is achieved via ''#pragma repy'' directive. Additionally, we can also specify what restrictions file is to be associated with this test file. This is achieved by providing an argument to ''#pragma repy'', yielding: ''#pragma repy restrictions.file''. If no argument is specified, UTF will use ''restirctions.default''.

Rest of the file is written as a regular Repy file. Same as with Python testing, your tests should not produce any output, except if some condition has not been met.

{{{
#!python

#pragma repy


def test_create():
def test_destroy():
def test_up():
def test_down():
}}}

==== Repy Execution Environment ====

Testing whether or not Repy Execution Environment is behaving properly is a more daunting task to accomplish. So, let's say you want to test that print statement behaves the way it should.

This type of testing should be seen as external process testing, or complete black-box testing.

Remember, we need to use ''#pragma out'' directive. What this says is that the test file which is being executed is support to produce output on standard out.

{{{
#!python

# This is a repy file!
#pragma repy

# The output mush match this string.
#pragma out Hello Out.

print 'Hello Out.'
}}}

==== Restrictions ====

How do you verify that the restrictions file is behaving the way it should? 

Basically, you need to define the restriction file you want to use as ''#pragma repy <file>'' directive. Also, we have to make sure that the file throws an exception containing ''not allowed'' string. Remember -- exceptions are always thrown on standard error.

The restriction file we are using does not allow function calls. Consequently, upon a function call, an exception will be thrown stating that we are not allowed to perform that action.

{{{
#!python

#pragma repy restrictions.callomit

#pragma err not allowed

def callee()
  print 'Specified restriction file should not allow this function call.'


if __name__ == '__initialize__':
  callee()

}}}

[[BR]]
=== Node Manager Example ===
----
Some software components require additional steps before and after the test execution. One such component is the node manager which is built around server-client architecture. As such, we need to initialize the state needed to run the node manager on the local node. 

Basically, all of the initialization code will be located inside __ut_nm_setup.py__ (formally known as nminit.py) file. This file is executed before any tests and it is also responsible for starting a local instance of node manager. Basically, here is what the file looks like.

{{{
#!python

#
import utfutil

# It initializes the state needed to run the node manager on the local node.
def initialize_state():
  ...



# Start the local instance.
def start_instance():
  identifier = 'nm_instance'
  args = ('python', 'nmmain.py')
  utfutil.spawn(args, identifier)




if __name__ == '__main__':
  initialize_state() 
  start_instance()

}}}

After all tests have finished, UTF will try to find and execute the shutdown script (__ut_nm_shutdown__). This script is responsible for deleting the initialization files and stopping the node manager instance. Here is what the file looks like:


{{{
#!python

#
import utfutil



# Stop the local instance.
def stop_instance():
  identifier = 'nm_instance'
  utfutil.kill(identifier)




if __name__ == '__main__':
  stop_instance()

}}}