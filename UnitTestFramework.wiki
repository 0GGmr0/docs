= Seattle's Unit Test Framework Alpha Documentation =

----
[[TOC(inline)]]
----

[[BR]]
== Abstract ==
----
The purpose of this document is to outline the most important features and to gather as much feedback as possible with respect to the new testing framework. We will be referring to Testing Unit Framework as UTF.

Please feel free to add any comments or concerns at the bottom of the page.

[[BR]]
== Requirements ==
----
Before diving into design and examples, I would like to specify requirements, so that the users have a better understanding of what the goals are. 

 * Above everything, writing a unit test module should be simple and obvious for new users.
 * Test module should be able to have many small test cases and developer should be able to group them into test suites.
 * The framework should allow advanced users to perform non-trivial tests.
 * The framework should allow users to easily select what tests to run (whole module or specific test cases).
 * The framework back-end needs to be simple and extendible.

When translating requirements into objectives, we are faced with a non-trivial task, since some requirements are more important than others. As a result, advanced features are somewhat limited (for instance there is not support for test trees).

[[BR]]
== Design ==
[[BR]]

UTF behaves similarly to python's standard unittest library, with addition of several other features suitable for Seattle. Those are:

 * Testing within Repy execution environment.
 * Ability to specify different restrictions for different Repy test files.
 * Testing for standard out and standard error messages.
 * Support for setup and shutdown scripts.

Having this in mind, you are probably asking yourself: 'Well, how do I achieve this?'. Obviously, we need to be able to hint or to instruct the framework about our needs. Those instructions are embedded either in the file itself or the filename. Below, we discuss each aspect.

When hinting the UTF:

 * that the test file is suppose to be run inside the Repy execution environment,
 * or to use a non-default restrictions,
 * or that the executed test has to produce a specific output on standard out or/and standard error

we need to use the following syntax:

{{{
#!python

#DIRECTIVE TYPE [ARGS]
}}}

The directive name is always going to be '''pragma''' (a directive communicating additional "pragmatic" or implementation-specific information). Therefore, the more specific syntax is:

{{{
#!python

#pragma TYPE [ARGS]
}}}

The following #pragma directives are allowed. When an unknown #pragma directive is encountered, UTF reports an error.

{{{
#!python
"""
Instructs UTF that this test file is suppose to be run inside Repy execution environment. 
Restriction file argument is optional -- if not specified restrictions.default is used.
If this directives is omitted, UTF assumes that your test file is a standard Python
file.
"""
#pragma repy [RESTRICTIONS FILE]

"""
Instructs UTF that this test file is suppose to produce some output on standard out. 
If the TEXT argument is specified, UTF will try to find TEXT substring. IF TEXT is not 
specified, UTF makes sure that the standard out data is not empty.
"""
#pragma out [TEXT]

"""
Instructs UTF that this test file is suppose to produce some output on standard error. 
If the TEXT argument is specified, UTF tries to find TEXT substring. IF TEXT is not 
specified, UTF makes sure that the standard error data is not empty.
"""
#pragma error [TEXT]
}}}


----


Other features are encoded inside of the ''' filename'''. Those are:

 * Which module does the test file belong to.
 * Does the module have setup and shutdown scripts?
 * Whether or not the test file will be executed by default.

All test files have to follow a strict naming convention: 

{{{
#!python

ut_<module name>_<descriptor>.py.
}}}

A module can have multiple test files associated with it.

Furthermore, a module may contain two special descriptors: '''setup''' and '''shutdown'''. When running full module testing, ut_<module>_setup.py is executed at the '''beginning''' and ut_<module>_shutdown.py at the '''end''' of the execution. This is primarily used by more complicated modules, which require initialization and clean-up steps.

Test files with the above mentioned syntax are executed '''by default'''. To exclude them from default execution, '''prepend the filename with _'''. This way, the test file has to be executed '''explicitly'''.

----


When running tests, a developer is presented with three different possibilities:
 * Run all tests for all modules:

{{{
#!python

$ utf.py

}}}

 * Run all tests for a specific module

{{{
#!python

$ utf.py --module <module name>
$ utf.py -m <module name>

}}}

 * Run a specific test file.

{{{
#!python

$ utf.py --file <file>
$ utf.py -f <file>

}}}

[[BR]]
== Examples ==
----


The following examples are not meant to be complete test cases (or to follow standard testing practices) for some module, but instead, are there to demonstrate a specific feature.

=== Single Test File ===

Now, let us consider a trivial use case. We'll be designing a random number generator.

There are two methods defined:

{{{
#!python

def init_rng(seed):
def generate_next(rng):

}}}

We are testing for two conditions: 
 * Given two random number generators with different seeds, they should produce different outputs.
 * Sanity check -- input validation.

{{{
#!python

# FILE: ut_rng.py

# Create a method that tests for a given objective.
def test_seed():
  seed1 = 32
  seed2 = 13

  rng1 = rng_init(seed1)
  rng2 = rng_init(seed2)

  next1 = generate_next(rng1)
  next2 = generate_next(rng2)

  # Make sure those two numbers are not the same.
  assertNotEqual(next1, next2)

def test_invalid_seed():
  assertRaises(BadInputException, rng_init("lol"))

# Register tests with our Unit Test Framework (UTF), by passing it
# a functor and a description.
registerTest(test_seed, "testing different seeds")
registerTest(test_invalid_seed, "testing invalid seed parameter")

}}}

When runing the tests you should an output that looks something like this:

{{{
#!python

$ Testing rng module
$   Running ut_rng_different_seeds.py              [ PASS ]
$   Running ut_rng_invalid_seed.py                 [ PASS ]

}}}

This is a very simple scenario, and hopefully it illustrates some of the basics of UTF.


=== Module Testing ===

Another, more complicated example, would be a IP <-> DNS converter.

There are two functions defined:

{{{
#!python

def to_ip(address):
def from_ip(ip):

}}}

Even though the logic behind this module is simple, testing is not. There are quite a few things that need to tested for: valid input, invalid input, boundary cases, etc. Therefore, when dealing with more sophisticated unit tests, it might be useful to separate test cases into test suites (files).

{{{
#!python

# FILE: ut_converter_ip_invalid.py


def test_ip_out_of_range():
  ...

def test_ip_non_routable():
  ...

def test_ip_zero():
  ...

addCases(test_id_out_of_range, test_id_non_routable, test_id_zero())
}}}


{{{
#!python

# FILE: ut_converter_from_ip_valid.py

...
}}}


{{{
#!python

# FILE: ut_converter_to_invalid.py

...
}}}


{{{
#!python

# FILE: ut_converter_to_ip_valid.py

...
}}}


Now, all you have to do is execute:


{{{
#!python

$ utf.py -m converter
}}}

Which will hopefully produce:

{{{
#!python

$ Testing converter module
$   Running ut_converter_ip_invalid.py                    [ PASS ]
$   Running ut_converter_from_ip_valid.py                 [ PASS ]
$   Running ut_converter_from_ip_invalid.py               [ PASS ]
$   Running ut_converter_to_ip_invalid.py                 [ PASS ]
$   Running ut_converter_to_ip_invalid.py                 [ PASS ]
}}}

=== Standard Out Test ===

How do you test if an application produces the correct output? Well, define '''#pragma out''' directive with expected argument.

{{{
#!python

#pragma out Hello Out.

import sys

sys.stdout.write("Hello Out.")
}}}

=== Restrictions File & Standard Error ===

How do you verify that the restrictions file is behaving the way it should? First of all, you need to define the restriction file you want to use as repy pragma argument. Also, we have to make sure that the file throws an exception containing ''not allowed'' string.

{{{
#!python

#pragma repy restrictions.callomit

#pragma err not allowed

sleep(1)

}}}

== Reference ==
  * assertTrue(expr[, msg])[[BR]]
    Signal a test failure if expr is true; the explanation for the error will be msg if given, otherwise it will be None.

  * assertFalse[[BR]]
    Signal a test failure if expr is false; the explanation for the error will be msg if given, otherwise it will be None.

  * assertEqual(first, second[, msg])[[BR]]
    Test that first and second are equal. If the values do not compare equal, the test will fail with the explanation given by msg, or None.

  * assertNotEqual[[BR]]
    Test that first and second are not equal. If the values do compare equal, the test will fail with the explanation given by msg, or None.

  * assertRaises[[BR]]
    Test that an exception is raised when callable is called with any positional or keyword arguments that are also passed to assertRaises(). The test passes if exception is raised, is an error if another exception is raised, or fails if no exception is raised. To catch any of a group of exceptions, a tuple containing the exception classes may be passed as exception.
