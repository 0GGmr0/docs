= DNS server libraries (dnsserver.repy) =

== What is it? ==

dnsserver is a repy library which allows your program to interpret and respond to DNS queries. It is intended for use as a tool for servers, though query formatting may be implemented in the future.




== Public Methods ==

dnsserver currently has only one public method: dnsserver_registercallback. While you are free to use the private methods included as well, do so at your own discretion. They may behave in unexpected, possibly non-DNS-compliant ways if not treated properly.

{{{
#!python
def dnsserver_registercallback(listen_port, listen_ip, callback_function):
  """
  <Purpose>
    This method registers a callback to be run whenever a DNS-formatted message 
    arrives at the listen_port. Mechanically speaking, this means that it adds 
    a key : value pair to _callback_registry with the form 
    'connection_handle' : 'callback_function', and begins listening for 
    messages on listen_port.

  <Arguments>
    listen_port
      The UDP port on which we listen for DNS messages. If this is being used 
      in a vessel, it must be a GENIPORT.

    listen_ip
      The IP address on which we listen for DNS messages. This will generally 
      be that returned by getmyip(), but we leave it up to the client to set 
      this, since there may be multiple network interfaces to choose from.

    callback_function
      The function which will be called whenever we receive a DNS message on 
      its associated port. This function should take exactly one argument: A 
      dictionary with the following form:

  {
    'raw_data':                <long string> (network raw)
    'remote_ip':               string (formatted unicode, IP Address)
    'remote_port':             integer
    'communication_id'         string (network raw)
    'query_response'           boolean
    'operation_code'           integer
    'authority_advisory'       boolean
    'truncation'               boolean
    'recursion_desired'        boolean
    'recursion_accepted'       boolean
    'z'                        boolean
    'authentic_data'           boolean
    'checking_disabled'        boolean
    'error_code'               integer (4 bit)
    'question_count'           integer (16 bit)
    'answer_count'             integer (16 bit)
    'authority_record_count'   integer (16 bit)
    'additional_record_count'  integer (16 bit)   )
    'questions': array of dictionaries containing:
        'name'                  string (formatted unicode, IP Address)
        'type'                  string (formatted unicode, eg A, AAAA, MX)
        'class'                 string (formatted unicode, eg IN, HE, CH)
    'answers': array of dictionaries containing:
        'name'                  string (formatted unicode, IP Address)
        'type'                  string (formatted unicode, eg A, AAAA, MX)
        'class'                 string (formatted unicode, eg IN, HE, CH)
        'time_to_live'          integer (seconds, 32 bit)
        'answer_data'           dictionary (format based on type)
  }

  # The 'answer_data' dictionary field can have various formats. Here are the 
  # three which are currently supported:
    SOA:
  'mname' <IP>
  'rname' <IP>
  'serial' <32 bit int>
  'refresh' <32 bit int>
  'retry' <32 bit int>
  'expire' <32 bit int>
  'minimum' <32 bit int>
    NS:
  'address' <Domain Name>
    A:
  'address' <IP>


  <Exceptions>
    Exception
      This is a global exception, but the only time it has been known to occur 
      is when recvmess is given a port which we aren't allowed to access.

  <Side Effects>
    When the callback function is registered, a listener will be opened on 
    listen_port, which could possibly interfere with other applications 
    running on the local machine. It's unlikely, but worth mentioning.

  <Returns>
    A connection handle, which can be used by stopcomm() to end the connection.
  """

  # Start listening on the given listen_port. _connection_received_callback will
  # run whenever we receive a UDP packet on listen_port.
  connhandle = recvmess(listen_ip, listen_port, _connection_received_callback)

  # Associate the connection handle with the callback function, so that we can 
  # retrieve it later.
  _dnsserver_callback_registry[connhandle] = {
      'callback_function' : callback_function,
      'local_port' : listen_port,
      'local_ip' : listen_ip }

  # For now, we return the 
  # commhandle given by recvmess, so that the client can halt the connection 
  # as necessary. I'd like to abstract this, but it's not urgent, and I'm 
  # not sure of a good way to do it. There *is* the possibility of an error, if 
  # a connection is terminated, and then a new callback is registered on the 
  # same port, since we currently make no attempt to remove old callbacks from 
  # the dictionary.
  return connhandle
}}}

As the above code block suggests, this method will conveniently send your registered callback function a dictionary whenever a DNS query is received, with the listed arguments inside it.



== How do I use it? ==

Just include dnsserver.repy in your code as a dependency! This code is intended as a module; it has no main code body inside. All you have to do is pass a method name, IP, and hostport to dnsserver_registercallback, and it will begin listening for DNS connections as instructed.

There is currently no way to instruct dnsserver to stop processing requests; this will be implemented soon.



== Debugging ==

There are unit tests included as well; any file enclosed with a ut_ prefix contains unit tests for various aspects of server behavior. To run these, simply preprocess them and use them as arguments for utf.py. You'll need to include dnsserver.repy in the same directory when you preprocess them, of course.