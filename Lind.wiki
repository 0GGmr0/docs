= Lind: Secure Lightweight Cloud Computing =

Lind is an attempt to provide a new secure lightweight cloud computing environment in the form of a new library operating system.  The goal of the project is to create a lightweight cloud runtime environment for x86, using [http://code.google.com/p/nativeclient/ Native Client (NaCl)] and [wiki:RepyApi Repy].  The project will implement a useful subset of the POSIX API within !NaCl to run through Repy.  This wiki page details the motivation and design of Lind, and explains how you can start using it yourself.

[[TOC(inline)]]


[[BR]]
== Motivation ==
----
The motivation of this !NaCl Repy hybrid is to expand !NaCl’s access to the system to commonly used functionality like sockets and simple file I/O, while still providing the necessary spatial and  performance [https://seattle.cs.washington.edu/html/netadmins.html isolation]. as well as portability to make running untrusted applications anywhere possible.  We think when coupled !NaCl’s safe execution, this makes a safe and powerful environment for some class applications which have complex compute requirements, but simple system access needs. 

[[BR]]
== Design ==
----

Lind is designed to minimize its footprint within the TCB. To do that, most of the Lind code runs within !NaCl !RePy. 

We have added support to allow !RePy programs to launch !NaCl instances via a new !RePy system call.  The ''safe_execute'' system call allows the application to specify a file from within its working directory to execute.  safe_execute uses a process similar to sel_launcher to fork a new sel_ldr process with the program and arguments.  When !NaCl starts it establishes IMC connection to communicate, these channels are opened and then handed over to the !RePy program. From the !RePy program you are able to query if the !NaCl instance is still running, get its channels and kill it. All other operations are blocked from the !RePy program.

Using the safe_execute mechanism, we can build a library OS.  The !RePy program runs an RPC server which allows for it to service calls from the !NaCl instance.  With in the !NaCl instance, we run a modified glibc where each system call of interest is redirected to the !RePy server.  The initial version of Lind will focus on networking and file I/O.  So for example, the fopen system call, is marshaled and sent via RPC to the !RePy server.  The !RePy server opens the file on behalf of the !NaCl program (with all the restrictions !RePy programs have on their file operations).  

=== Faking System Calls ===

One nice property of the Lind design is that we can pick which system calls we will support with Lind.   System calls broadly fall into a few categories. First, system calls which we leave alone. Those are calls like brk.  Second, some calls are emulated, for example open.  Third, some calls will be faked.  Faked calls are those which there will be no direct analog for in !RePy.  For instance file system permission related calls will be faked because !RePy programs do not have access to the global file system, only their own local file system.

=== Library OS ===

One part of Lind is the library OS built with !RePy.  Though in the early stages of development, we intend to make a component based system, where components satisfy different subsystems requests.  The intent is to allow custom steps including transparent in memory file systems, or over network file systems.  Finally, we intend to support process migration, so that will be designed into the OS base.

=== Why Seattle ===

There are several things that using Seattle gives us.  !RePy has more advanced policy mechanism with regards to resource consumption. !RePy has rate limiting for file and network I/O.   It has white and black lists for network connections ports etc.  It has memory use monitoring, and CPU consumption monitoring. 


[[Image(LindDesignDocument.png)]][[BR]]
Conceptional view of the Lind library OS.

=== Goals ===
 * Minimal additions to the !NaCl TCB.
 * Use Seattle secured Python where possible

=== Description ===

Lind connects !NaCl and !RePy using !NaCl's IMC system.  IMC provides socket and message passing like interfaces between an a !NaCl program and an external process.  

=== Trust Domains ===

Code can be broken down into trusted and untrusted.  The majority of the untrusted Lind code is sandboxed by !NaCl or !RePy.  In Lind, the TCB (trusted code base) is the native client sel_ldr and the !RePy VM, but we also make a some minor additions including using the !NaCl Python IMC bindings, and adding a new !RePy system call to launch a !NaCl instance.

The whole system runs in 3 or more process:

  * The !RePy VM
  * One or more !NaCl sel_ldrs
  * The !RePy auditing process

[[Image(LindDesignDocument (1).png)]]

[[BR]]
== How programs are built and run ==
----
Lind programs are standard C programs (or anything else gcc compiles to x86); however, they must be compiled with the Native Client GCC implementation, and linked with a special version of glibc built for Lind.  The native client gcc is a slightly modified gcc which produced x86 code which can be verified.  The Lind glibc redirects system calls normally sent to the OS back into the Lind python runtime. Besides that, building application for Lind is no different than building standard programs with GCC.

[[BR]]
== Getting Lind ==
----
We are working on the first version of Lind now.  If you would like to be an early beta tester please email Chris.
